;;; repl-driven-development-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from repl-driven-development.el

(autoload 'repl-driven-development "repl-driven-development" "\
Make Emacs itself a REPL for your given language of choice.

  Suppose you're exploring a Python/Ruby/Java/JS/TS/Haskell/Lisps/etc
  API, or experimenting with an idea and want immediate feedback.
  You could open a terminal and try things out there; with no editor
  support, and occasionally copy-pasting things back into your editor
  for future use.  Better yet, why not use your editor itself as a REPL.

  Implementation & behavioural notes can be found in the JavaScript
  Example below.

  ######################################################################
  ### JavaScript Example ---Basic usage, and a minimal server ##########
  ######################################################################

     ;; C-x C-j now evaluates arbitrary JavaScript code
     (repl-driven-development [C-x C-j] \"node\")

  That's it! Press “C-x C-e” on the above line so that “C-x C-j”
  will now evaluate a selection, or the entire line, as if it were
  JavaScript code.  ⟦Why C-x C-j? C-x C-“e” for Emacs Lisp code, and C-x
  C-“j” for JavaScript code!⟧ For instance, copy-paste the
  following examples into a JS file ---or just press “C-x C-j” to
  evaluate them!

      1 + 2                                     // ⮕ 3
      1 + '2'                                   // ⮕ '12'
      let me = {name: 'Jasim'}; Object.keys(me) // ⮕ ['name']
      me.doesNotExist('whoops')                 // ⮕ Uncaught TypeError
      [ ...Array(45).keys() ]          // ⮕ Multi-line overlay of 0..44

  All of these results are echoed inline in an overlay, by default.
  Moreover, there is a *REPL* buffer created for your REPL so you
  can see everything you've sent to it, and the output it sent
  back.  This is particularly useful for lengthy error messages,
  such as those of Java, which cannot be rendered nicely within an
  overlay.

  How this works is that Emacs spawns a new “node” process, then
  C-x C-j sends text to that process.  Whenever the process emits
  any output ---on stdout or stderr--- then we emit that to the
  user via an overlay.

  Finally, “C-h k  C-x C-j” will show you the name of the function
  that is invoked when you press C-x C-j, along with minimal docs.

  A useful example would be a minimal server, and requests for it.

     // First get stuff with C-x C-e:
     // (async-shell-command \"npm install -g express axios\")

     let app = require('express')()
     let clicked = 1
     app.get('/hi', (req, res) => res.send(`Hello World × ${clicked++}`))

     let server = app.listen(3000)
     // Now visit   http://localhost:3000/hi   a bunch of times!

    // Better yet, see the output programmatically...
    let axios = require('axios')
    // Press C-x C-j a bunch of times on the following expression ♥‿♥
    console.log((await axios.get('http://localhost:3000/hi')).data)

    // Consider closing the server when you're done with it.
    server.close()

  Just as “Emacs is a Lisp Machine”, one can use “VSCodeJS” to use
  “VSCode as a JS Machine”.
  See http://alhassy.com/vscode-is-itself-a-javascript-repl.

  ######################################################################
  ### Description of Arguments #########################################
  ######################################################################

  - KEYS [Vector]: A vector such as [C-x C-p] that declares the keybindings for
    the new REPL evaluator.

  - CLI [String|Symbol]: A string denoting the terminal command to start your
    repl; you may need an “-i” flag to force it to be interactive even though
    we use it from a child process rather than a top-level shell.

    This argument may also be one of the following unquoted symbols:

        java, python, terminal, javascript

    These are preconfigured REPLs; e.g., see the docs of
    function `repl-driven-development-preconfiguration:python'.

  - PROMPT [Regular Expression]:
    What is the prompt that your REPL shows, e.g., “>”.
    We try to ignore showing it in an overlay that would otherwise hide
    useful output.

  - DOCS [String]: A space-seperated string denoting a list of language
    documents you'd like to associate with your repl.
    Invoking your repl with “C-u C-u” will show the documentation
    of the word at point.  This is done using `devdocs'.

    For example,
      (repl-driven-development [C-x C-j] \"node\" :docs \"javascript express\")
    Would allow us to invoke “C-u C-u C-x C-j” with the cursor on the
    word, say, “listen” and we'll see some useful docs (along with
    example uses) of this Express library method “listen”.

    Visit https://devdocs.io/ to see the list of documented languages
    and libraries.

  - INIT [String | List<String>]: Any initial code you'd like your
    repl to be initiated with. For example, imports of standard libraries
    is probably something you'd always like to have on-hand; or perhaps
    some useful variables/declarations/functions.

  - BLINK [Face]: Any face with a background. It is used to briefly highlight
    the current line that is being sent to the REPL process.

  - INPUT-REWRITE-FN [1-arg function]: A function called to rewrite text
    before submitting it to the repl. For example usage, see the docs of
    function `repl-driven-development-preconfiguration:python'.

  - ECHO-REWRITE-FN [1-arg function]: A function called to rewrite repl
    output before echoing it to the user.  For example usage, see the docs
    of function `repl-driven-development-preconfiguration:python'.

    Intentionally meant for human friendly pretty-printing, not for
    a READ protocol. Those serve different goals.
    The default READ protocol is this echo-rewrite-fn.
    Enter “M-x .*-read” to see the docs of the READ protocol
    for any REPL defined with this macro.

  - NAME [Symbol]: The name of the function associated to the keybinding
    KEYS. By default, the name is “CLI-eval”. This is used to namespace
    almost all other functions created by this macro.

  ### Misc Remarks #####################################################
  For more documentation, and examples,
  see URL `http://alhassy.com/repl-driven-development'.

  VSCode has a similar utility for making in-editor REPLs, by the
  same author: See URL `http://alhassy.com/making-vscode-itself-a-java-repl'.

(fn KEYS CLI &key (PROMPT \">\") DOCS (INIT \"\") (BLINK \\='\\='pulsar-yellow) NAME (INPUT-REWRITE-FN \\='\\='identity) (ECHO-REWRITE-FN \\='\\='identity))" nil t)
(register-definition-prefixes "repl-driven-development" '("rdd@" "repl-driven-development-"))

;;; End of scraped data

(provide 'repl-driven-development-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; repl-driven-development-autoloads.el ends here
