Until I get my task tracker semi-workable, I'm going to keep the list of things I wish my emacs rig did as a simple TODO file.

Note that a lot of these aren't emacs-specific - they're just things I wish my editor would do. elisp is Turing-complete, though, even if it's not a great language overall...

-Figure out how to use this repository as my Emacs configuration on Windows. Right now I'm limping by on standard Emacs, and it's annoying.

-Get auto-pair or electric-pair working. I usually enter both my delimiters before going back and adding the contents anyway, so it would probably fit my style quite well. The problem is that there are lots of options and I'm not sure which one would be best. See http://www.emacswiki.org/emacs/AutoPairs for a lengthy discussion and various snippets/links that would probably be helpful.

-I really want a block-comment-mode. Basically, when I'm writing block comments, I shouldn't need to worry about when to line-wrap and where to break. It's like plain text, more or less. It needs not to interfere when I'm customizing indentation, but basically, I should be able to say "start a block comment", and it should flow/wrap my text for me, with whatever syntax is used for block comments by the current major-mode. (In python-mode, something similar should be done for docstrings.) Further research shows that auto-fill-mode comes close to this - sounds like it can't handle reflowing a paragraph very well at all, and also like it's 'always-on', while I'd like this to be active only in comment-only lines. Still, even if I wind up writing my own variation, starting off with the auto-fill-mode code would seem to be reasonable. Okay, auto-fill sorta works-ish, but not really. Probably, a few hours hacking on some hybrid of http://www.emacswiki.org/emacs/RefillMode and http://www.emacswiki.org/emacs/FillingComments, and thinking about how to get it to recognize things like docstrings in Python's case would give me what I want. http://stackoverflow.com/questions/4711179/auto-expanding-blocks-of-comments-in-emacs is a pretty useful reference, too, I think.

-I'd also like context-sensitive paragraph filling. That is, in comments, my fill-column value is 79, but if I'm in a Python docstring, fill-column should be 72.

-I'd like to display the current named block in my modeline. So, in Python, if I'm editing method foobar of class Testing, my modeline would have 'Block: Testing.foobar' in it. Problem is that it could easily extend past the number of characters I have available in the modeline; a variable that sets how many characters it will use would do the job, though.

-Find/use a PHP mode that isn't teh suck. The Aquamacs default is awful.

-I'd like emacs to autodetect the indentation format of a file, and override my preference if it doesn't match. There is a mode built to do exactly that, it seems: http://git.savannah.gnu.org/gitweb/?p=dtrt-indent.git;a=blob_plain;f=dtrt-indent.el;hb=HEAD Consider integrating it some year when I have the time.

-Figure out/steal/write a good cross-file find-and-replace. I can see why so many guys just use a Perl one-liner, but being able to do this from inside your editor is pretty convenient.

-I'd like some convenient shortcut for 'Move forward one name-delimiter.' For instance, in standard Python, '_' separates words inside names. In other languages, HumpsOfTheCamelCase do so. Either way, Meta-f and Meta-b include in-name words as distinct entities in some modes but not in others, and I'd like a sane, consistent way to deal with that sort of cursor movement.

-It might be interesting to experiment with semantic-coding commands. This idea was inspired by thinking about yasnippet, and how basically, it's used to cut down on boilerplate. Boilerplate is semi-language-specific, but it's really got more to do with individual programmers' styles - there are common idioms, but everyone tends to have their own. So, might it be interesting to build some interface to a collection of snippets that's basically "Do this idiom for the current language"? Block-comment's one emacs already has, but there are lots: debug output, while loop/for loop, if/else, if/elif/else, new class, new function, etc... This whole idea isn't entirely unrelated to refactoring, actually.

-A specific semantic-coding idea: have a command that lets you invert string delimiters. Sometimes you realize mid-stream that you used the wrong ones, and as long as your string is still valid, the editor should be able to find your delimiters and invert them. Now you can keep on cranking.

-See whether rope supports any kind of intelligent argument list fetching. If it does, it might be possible to write a parameter suggestion tool. Obviously, this is a big one, and not something I'm likely to really tackle. Well, maybe it's not as tough as I think - might be able to incorporate some cleverness between YASnippet and ropemacs so that there's a YASnippet for *current Python function args*, and it tabs you through each one? Actually, yeah - if nothing else, it might be possible to generate a new snippet based on what we're getting from ropemacs, so the yasnippet "jump to next dynamic field" behavior would basically let us fill in args while seeing what the original values were. I haven't actually started using YASnippet yet, so perhaps that's beyond the bounds of what it's capable of.

-Get ropemode to be more effective. A lot of expressions that seem completable aren't. Sometimes this is probably for very valid reasons (not wanting to evaluate every darned statement in the project), but it doesn't seem like knowing what the current "self" is would be impossibly hard. This is serious rope development, and possibly not in sync with what the rope crew would like to do. Let's call it a pipe-dream.

-Write/request a better interface for rope-find-occurrences. It just gives you a buffer telling you where it shows up (and includes the def statement for a function, which seems a bit funky to me) - it ought to be simple to hop directly to it, eh?

-There should be a command in python-mode to break a comma-separated list of values to one-per-line, with proper indentation. I find myself doing this relatively often.

-Autocompletion should display the whole string that would be inserted, not just the remainder of it (and then insert only what's needed to complete it). Not sure why that bugs me, but I swear it was doing that at some point when I was working on getting it to work... This is weird now - it displays a character or two from the existing string, plus everything it would add.

-Figure out a way to make rope-completions faster. It's the source of that half-second delay before anything happens after I ask for auto-completion, and it honestly slows me down. I can usually finish typing the expression faster than I can auto-complete it. I've improved this some by the simple expedient of byte-compiling pymacs.el, but still things like wx.<TAB> chug for fifty seconds or so before suggesting completions. I realize that's abusive, given just how many names are in that namespace, but it does seem like it should be possible to keep a pretty static analysis of system-wide packages, and that completions on names that correlate to those packages shouldn't be so slow. It feels like it's doing dynamic analysis of the 'wx' package, but once it's been imported, shouldn't we be able to just check whether the module on disk has updated, and if not, need no more dynamic analysis? I should probably ask/bug-report this on the mailing list.

-autocomplete.el should have a toggle that makes scrolling to the bottom of the list scroll the list downward, and scrolling to the top upward, for when more than list-length completions are possible. It'd be very convenient.

-Get tab behaving properly. That means calling yasnippet/code-completion as appropriate, indentation when appropriate, retaining minibuffer autocompletion, and Shift-Tab cycling backwards through autocompletions (I really want that, for reasons I don't quite understand).

-Get yasnippet working. For now, it's okay if I don't use tab as the keybinding - that's some sweet-looking software, and I really want to start integrating it into my workflow. Yeah, I'll go crazy when I'm stuck on systems that don't have it, but it looks really neat. (Hmmm, interesting thought - I'd probably start to forget the details of syntax for snippets I relied on extensively. How much help from your editor is too much?)

-Get/write a diff/patch-viewing mode that doesn't suck.

-This is long-term, since my task tracker doesn't exist yet, but I'd like to hack up a basic minor-mode for it, if it ever gets far enough for that to be useful. Subtle hints when a name/block has annotations (toggleable, of course), easy keystroke to view the associated annotation/task, easy way to create annotations/attach existing annotations to some code... I should probably do this in elisp, not because it's the right thing from an engineering perspective, but because it would force me to learn a lot about the language. It'd be annoying to have to do all the work again in elisp, though, and there is Pymacs...

-When I'm yanking something into an indented block, python-mode ought to assume that I want it indented to that block's depth and adjust the leading whitespace for each line accordingly. This applies to indentation in general; it might work in most modes, for all I know. With Python, there's the perennial problem of no delimiters; it's not necessarily right to go to the highest possible indentation on a newline. For yanking, though, I'll bet it's the right call most of the time. If it's not, you're just an indent command away from having the right depth.

-Frequently, especially when writing prose, I find my fingers doing the dance any given editor requires to swap elements in a comma-separated list. Seems like that shouldn't require too many keystrokes. I'm sure Emacs can do this with a bit of hacking, and maybe it already does...

-It should speak RTF fluently. I don't care so much about fancy formats, as those should be converted, but RTF is a pretty convenient format that allows you a surprising amount of control without being too crazy. If you're prepping stuff for basic printing, or sending to not-hardcore-power-users, RTF works beautifully, and I don't see why I should have to leave my main editor for working with this stuff. Yes, I know there's enriched-mode, but that's not exactly standard for word processors. Oh yeah - there is this, which looks pretty unmaintained, but it might be a starting point: http://savannah.nongnu.org/projects/emacs-rtf/ A little inspection indicates that the author isn't very far, it's probably abandoned, and uselessly inefficient. I suspect I'd be best off rolling my own...

-A mode in which English grammatical rules are automatically applied to anything that looks like a sentence. For instance, when I refactor a sentence, it ought to know that the first word gets capitalized. That might be the only thing I actually want, come to think of it...

-I'd really like a code folding minor-mode - just lets you hide/show blocks of code, by saying basically "fold at this line" and "unfold at this line". Something as naive as indentation level might work, but there are obviously problems with that - alternately, you could probably do something clever with the syntax parsers that most major-modes define (you'd probably want a mechanism to let a major-mode deal with what's a code-foldable line and what is not - otherwise, the weirder modes like js2-mode couldn't really work with it). Consider whether http://www.emacswiki.org/emacs/HideShow might have some good input.

=====Solved Tasks====

-Get ropemode/auto-complete.el completing .-expressions. WOOOO ANOTHER FEATURE DOWN!!! (of course, testing on a fifteen-line file doesn't really tell us how usable it'll be in practice...) Anywho, next really big target on the python-mode front is probably abusing rope-mode and overlays to pop up info on functions inline (only on request of course - args and suchnot). That'd be a serious undertaking.

-Figure out why using rope to rename things re-loads Python mode and all my related hooks for every buffer it impacts. This was indeed because of the stupid manner in which I'd written my python-mode hooks, and I've rewritten them to not do so much excessive work. This problem is SOLVED! woooooo!

-Autocompletion should not be invoked if there is whitespace directly before point (python mode).
