Until I get my task tracker semi-workable, I'm going to keep the list of things I wish my emacs rig did as a simple TODO file.

Note that a lot of these aren't emacs-specific - they're just things I wish my editor would do. elisp is Turing-complete, though, even if it's not a great language overall...

-I really want a block-comment-mode. Basically, when I'm writing block comments, I shouldn't need to worry about when to line-wrap and where to break. It's like plain text, more or less. It needs not to interfere when I'm customizing indentation, but basically, I should be able to say "start a block comment", and it should flow/wrap my text for me, with whatever syntax is used for block comments by the current major-mode. (In python-mode, something similar should be done for docstrings.)

-It might be interesting to experiment with semantic-coding commands. This idea was inspired by thinking about yasnippet, and how basically, it's used to cut down on boilerplate. Boilerplate is semi-language-specific, but it's really got more to do with individual programmers' styles - there are common idioms, but everyone tends to have their own. So, might it be interesting to build some interface to a collection of snippets that's basically "Do this idiom for the current language"? Block-comment's one emacs already has, but there are lots: debug output, while loop/for loop, if/else, if/elif/else, new class, new function, etc... This whole idea isn't entirely unrelated to refactoring, actually.

-A specific semantic-coding idea: have a command that lets you invert string delimiters. Sometimes you realize mid-stream that you used the wrong ones, and as long as your string is still valid, the editor should be able to find your delimiters and invert them. Now you can keep on cranking.

-Get ropemode/auto-complete.el completing .-expressions. I know ropemode can do it, so it seems like it should be a pretty simple change to get this working. Some progress made here, but I don't really understand why what I have even comes close to working. EDIT: I reverted the change that made it kinda work, because it was so darn slow.

-See whether rope supports any kind of intelligent argument list fetching. If it does, it might be possible to write a parameter suggestion tool. Obviously, this is a big one, and not something I'm likely to really tackle.

-Figure out why using rope to rename things re-loads Python mode and all my related hooks for every buffer it impacts. This was indeed because of the stupid manner in which I'd written my python-mode hooks, and I've rewritten them to not do so much excessive work. This problem is SOLVED! woooooo!

-There should be a command in python-mode to break a comma-separated list of values to one-per-line, with proper indentation. I find myself doing this relatively often.

-Get tab behaving properly. That means calling yasnippet/code-completion as appropriate, indentation when appropriate, retaining minibuffer autocompletion, and Shift-Tab cycling backwards through autocompletions (I really want that, for reasons I don't quite understand).

-Get yasnippet working. For now, it's okay if I don't use tab as the keybinding - that's some sweet-looking software, and I really want to start integrating it into my workflow. Yeah, I'll go crazy when I'm stuck on systems that don't have it, but it looks really neat. (Hmmm, interesting thought - I'd probably start to forget the details of syntax for snippets I relied on extensively. How much help from your editor is too much?)

-This is long-term, since my task tracker doesn't exist yet, but I'd like to hack up a basic minor-mode for it, if it ever gets far enough for that to be useful. Subtle hints when a name/block has annotations (toggleable, of course), easy keystroke to view the associated annotation/task, easy way to create annotations/attach existing annotations to some code... I should probably do this in elisp, not because it's the right thing from an engineering perspective, but because it would force me to learn a lot about the language. It'd be annoying to have to do all the work again in elisp, though, and there is Pymacs...

-When I'm yanking something into an indented block, python-mode ought to assume that I want it indented to that block's depth and adjust the leading whitespace for each line accordingly. This applies to indentation in general; it might  work in most modes, for all I know. With Python, there's the perennial problem of no delimiters; it's not necessarily right to go to the highest possible indentation on a newline. For yanking, though, I'll bet it's the right call most of the time. If it's not, you're just an indent command away from having the right depth.

-Frequently, especially when writing prose, I find my fingers doing the dance any given editor requires to swap elements in a comma-separated list. Seems like that shouldn't require too many keystrokes. I'm sure Emacs can do this with a bit of hacking, and maybe it already does...

-It should speak RTF fluently. I don't care so much about fancy formats, as those should be converted, but RTF is a pretty convenient format that allows you a surprising amount of control without being too crazy. If you're prepping stuff for basic printing, or sending to not-hardcore-power-users, RTF works beautifully, and I don't see why I should have to leave my main editor for working with this stuff. Yes, I know there's enriched-mode, but that's not exactly standard for word processors. Oh yeah - there is this, which looks pretty unmaintained, but it might be a starting point: http://savannah.nongnu.org/projects/emacs-rtf/ A little inspection indicates that the author isn't very far, it's probably abandoned, and uselessly inefficient. I suspect I'd be best off rolling my own...

-A mode in which English grammatical rules are automatically applied to anything that looks like a sentence. For instance, when I refactor a sentence, it ought to know that the first word gets capitalized. That might be the only thing I actually want, come to think of it...
