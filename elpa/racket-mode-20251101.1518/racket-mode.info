This is racket-mode.info, produced by makeinfo version 6.8 from
racket-mode.texi.

Copyright (C) 2013-2025 by Greg Hendershott.

   SPDX-License-Identifier: GPL-3.0-or-later
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Racket Mode: (racket-mode). Edit and REPL major modes for Racket lang.
END-INFO-DIR-ENTRY


File: racket-mode.info,  Node: Top,  Next: Introduction,  Up: (dir)

Racket Mode
***********

* Menu:

* Introduction::
* Install, Update, and Uninstall: Install Update and Uninstall.
* Configure::
* Architecture::
* Reference::
* Commands::
* Variables::
* Configuration functions::
* Faces::

— The Detailed Node Listing —

Install, Update, and Uninstall

* Use Emacs 28.1 or newer with NonGNU ELPA: Use Emacs 281 or newer with NonGNU ELPA.
* Configure Emacs to use MELPA::
* Install::
* Minimal Racket::
* Uninstall::
* Update::

Update

* Upgrading all packages::
* Updating just Racket Mode::

Configure

* Which major mode to use::
* Key bindings::
* Font-lock (syntax highlighting)::
* Completion at point::
* Completion in minibuffer::
* Xref (definitions and references)::
* Indent::
* paredit::
* smartparens::
* Appearance of parentheses::
* Edit buffers and REPL buffers::
* eldoc::
* Start faster::
* Inserting Unicode math symbols::
* Ligatures::

Commands

* Edit::
* Hash Langs::
* Explore::
* Run::
* Test::
* Eval::
* Collections::
* Macro expand::
* Packages::
* Debug::
* Other::

Edit

* racket-mode::
* racket-insert-lambda::
* racket-insert-symbol::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-add-require-for-identifier::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-input-mode::
* racket-align::
* racket-unalign::
* racket-complete-at-point::

Hash Langs

* racket-hash-lang-mode::
* racket-hash-lang-backward::
* racket-hash-lang-forward::
* racket-hash-lang-up::
* racket-hash-lang-down::
* racket-hash-lang-C-M-q-dwim::

Explore

* racket-xp-mode::
* racket-xp-describe::
* racket-xp-documentation::
* racket-xp-next-definition::
* racket-xp-previous-definition::
* racket-xp-next-use::
* racket-xp-previous-use::
* racket-xp-next-error::
* racket-xp-previous-error::
* racket-xp-tail-up::
* racket-xp-tail-down::
* racket-xp-tail-next-sibling::
* racket-xp-tail-previous-sibling::
* racket-documentation-search::
* racket-describe-mode::
* racket-describe-search::

Run

* racket-repl-mode::
* racket-run::
* racket-run-and-switch-to-repl::
* racket-run-module-at-point::
* racket-repl::
* racket-repl-describe::
* racket-repl-documentation::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-repl-clear::
* racket-repl-clear-leaving-last-prompt::

Test

* racket-test::
* racket-raco-test::

Eval

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::

Collections

* racket-open-require-path::

Macro expand

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::

Packages

* racket-package-refresh::
* list-racket-packages::
* racket-package-mode::
* describe-racket-package::

Debug

* racket-debug-mode::
* racket-debug-step::
* racket-debug-step-over::
* racket-debug-step-out::
* racket-debug-forward-breakable::
* racket-debug-backward-breakable::
* racket-debug-run-to-here::
* racket-debug-set-break-expression::
* racket-debug-clear-break-expression::
* racket-debug-toggle-break-expression::
* racket-debug-forward-break-expression::
* racket-debug-backward-break-expression::
* racket-debug-set-local::
* racket-debug-continue::
* racket-debug-go::

Other

* racket-mode-start-faster::
* racket-mode-start-slower::

Variables

* General variables::
* Hash lang variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::
* Showing information::
* Running racket and raco commands in a shell or terminal::
* Racket input method::

General variables

* racket-program::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-user-command-line-arguments::
* racket-browse-url-function::
* racket-xp-after-change-refresh-delay::
* racket-xp-highlight-unused-regexp::
* racket-xp-add-binding-faces::
* racket-xp-eldoc-level::
* racket-documentation-search-location::
* racket-expand-hiding::

Hash lang variables

* racket-hash-lang-token-face-alist::
* racket-hash-lang-module-language-hook::

REPL variables

* racket-repl-buffer-name-function::
* racket-submodules-to-run::
* racket-repl-history-directory::
* racket-history-filter-regexp::
* racket-images-inline::
* racket-imagemagick-props::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-images-do-not-use-svg::
* racket-pretty-print::
* racket-repl-command-file::
* racket-repl-echo-sent-expressions::

Other variables

* racket-doc-index-directory::
* racket-doc-index-predicate-function::
* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::
* racket-before-run-hook::
* racket-after-run-hook::
* racket-sexp-comment-fade::

Experimental debugger variables

* racket-debuggable-files::

Showing information

* racket-show-functions::

Running racket and raco commands in a shell or terminal

* racket-shell-or-terminal-function::

Racket input method

* racket-input-prefix::
* racket-input-translations::

Configuration functions

* Showing information: Showing information (1).
* Associating edit buffers with REPL buffers::
* Browsing file URLs with anchors::
* Configuring back ends::
* Running racket and raco commands in a shell or terminal: Running racket and raco commands in a shell or terminal (1).

Showing information

* racket-show-pseudo-tooltip::
* racket-show-echo-area::
* racket-show-header-line::
* racket-show-pos-tip::

Associating edit buffers with REPL buffers

* racket-repl-buffer-name-shared::
* racket-repl-buffer-name-unique::
* racket-repl-buffer-name-project::
* racket-project-root::

Browsing file URLs with anchors

* racket-browse-url-using-temporary-file::

Configuring back ends

* racket-add-back-end::

Running racket and raco commands in a shell or terminal

* racket-shell::
* racket-term::
* racket-ansi-term::
* racket-vterm::

Faces

* All::

All

* racket-keyword-argument-face::
* racket-reader-quoted-symbol-face::
* racket-reader-syntax-quoted-symbol-face::
* racket-here-string-face::
* racket-xp-def-face::
* racket-xp-use-face::
* racket-xp-unused-face::
* racket-xp-tail-target-face::
* racket-xp-tail-position-face::
* racket-xp-binding-lang-face::
* racket-xp-binding-lang-use-face::
* racket-xp-binding-import-face::
* racket-xp-binding-import-use-face::
* racket-xp-binding-local-face::
* racket-xp-binding-local-use-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::
* racket-doc-link-face::
* racket-ext-link-face::
* racket-doc-output-face::
* racket-doc-litchar-face::
* racket-repl-message::
* racket-repl-prompt::
* racket-repl-value::
* racket-repl-error-message::
* racket-repl-error-location::
* racket-repl-stdout::
* racket-repl-stderr::
* racket-hash-lang-text::



File: racket-mode.info,  Node: Introduction,  Next: Install Update and Uninstall,  Prev: Top,  Up: Top

1 Introduction
**************

The Racket Mode (https://www.racket-mode.com/) package consists of a
variety of Emacs major and minor modes, including:

   • ‘racket-mode’: A major mode to edit ‘.rkt’ files.  Generally
     assumes ‘#lang racket’.

   • *note racket-hash-lang-mode::: An alternative to ‘racket-mode’
     using behavior specified by a ‘#lang’ for colors, indent,
     expression navigation, etc.  _Experimental_.

   • *note racket-xp-mode::: A minor mode to enhance either edit mode.
     Explain and explore code, similar to background check-syntax in Dr
     Racket.

   • ‘racket-repl-mode’: A major mode to run programs and use a REPL.

   • Various other modes to support specific features:
        • *note racket-logger-mode::
        • *note racket-profile-mode::
        • *note racket-debug-mode::

   For code, issues, and pull requests, see the Git repo
(https://github.com/greghendershott/racket-mode).

   To sponsor this work, see GitHub Sponsors
(https://github.com/users/greghendershott/sponsorship) or PayPal
(https://www.paypal.me/greghendershott).


File: racket-mode.info,  Node: Install Update and Uninstall,  Next: Configure,  Prev: Introduction,  Up: Top

2 Install, Update, and Uninstall
********************************

The most common way to use Racket Mode is to install from a package
archive like MELPA or NonGNU ELPA.

   Some people also use a system like straight.el
(https://github.com/radian-software/straight.el).

   Note that Racket Mode is only available on MELPA (_not_ “MELPA
Stable”), and is available as a “rolling release” from NonGNU ELPA.

* Menu:

* Use Emacs 28.1 or newer with NonGNU ELPA: Use Emacs 281 or newer with NonGNU ELPA.
* Configure Emacs to use MELPA::
* Install::
* Minimal Racket::
* Uninstall::
* Update::


File: racket-mode.info,  Node: Use Emacs 281 or newer with NonGNU ELPA,  Next: Configure Emacs to use MELPA,  Up: Install Update and Uninstall

2.1 Use Emacs 28.1 or newer with NonGNU ELPA
============================================

Emacs 28.1 or newer comes configured to use NonGNU ELPA
(https://elpa.nongnu.org), in which case you can skip ahead to *note
Install::.

   With older versions of Emacs, you can use MELPA.


File: racket-mode.info,  Node: Configure Emacs to use MELPA,  Next: Install,  Prev: Use Emacs 281 or newer with NonGNU ELPA,  Up: Install Update and Uninstall

2.2 Configure Emacs to use MELPA
================================

Following is a quick guide that may work for you.  (For definitive
instructions and the latest trouble-shooting tips, please see
<https://melpa.org/#/getting-started>.)

   • Add the following to your ‘~/.emacs’ or ‘~/.emacs.d/init.el’:

     (require 'package)
     (add-to-list 'package-archives
                   '("melpa" . "https://melpa.org/packages/")
                   t)
     (package-initialize)

   • Restart Emacs.

     NOTE: If you ever get an error message about “contacting a host” or
     “downloading an archive”, the problem is not unique to Racket Mode.
     Please see <https://melpa.org/#/getting-started>.


File: racket-mode.info,  Node: Install,  Next: Minimal Racket,  Prev: Configure Emacs to use MELPA,  Up: Install Update and Uninstall

2.3 Install
===========

When Emacs is configured to use NonGNU ELPA or MELPA:

  1. Type ‘M-x’ ‘package-initialize’ ‘RET’ .

  2. Type ‘M-x’ ‘package-refresh-contents’ ‘RET’ .

  3. Type ‘M-x’ ‘package-install’ ‘RET’ ‘racket-mode’ ‘RET’ .

     NOTE: If you get an error message about “contacting a host” or
     “downloading an archive”, the problem is not unique to Racket Mode.
     Please see <https://melpa.org/#/getting-started>.


File: racket-mode.info,  Node: Minimal Racket,  Next: Uninstall,  Prev: Install,  Up: Install Update and Uninstall

2.4 Minimal Racket
==================

If you have installed the minimal Racket distribution (for example by
using the homebrew formula
(https://github.com/Homebrew/homebrew-core/blob/master/Formula/m/minimal-racket.rb))
Racket Mode needs some additional Racket packages.  A simple way to get
all these packages is to install the ‘drracket’ Racket package.  In a
command shell:

     raco pkg install --auto drracket

   A more-targeted approach is instead to install these specific
packages and their dependencies:

     raco pkg install --auto data-lib errortrace-lib macro-debugger-text-lib rackunit-lib racket-index scribble-lib drracket-tool-text-lib

   If you do _not_ want to use ‘racket-xp-mode’, then you can omit
‘drracket-tool-text-lib’.

   On a headless server, you might want to omit ‘gui-lib’.
Unfortunately, ‘racket-doc’ depends on ‘gui-lib’.  On the one hand, if
you uninstall ‘racket-doc’ and ‘gui-lib’, you will no longer be able to
access documentation when using a Racket Mode back end running there.
On the other hand, if you leave ‘gui-lib’ installed, you should be
careful to run the Racket Mode back end using ‘xvfb-run racket’.


File: racket-mode.info,  Node: Uninstall,  Next: Update,  Prev: Minimal Racket,  Up: Install Update and Uninstall

2.5 Uninstall
=============

To uninstall Racket Mode, simply type ‘M-x’ ‘package-delete’ ‘RET’
‘racket-mode’ ‘RET’ .

   You should probably also exit and restart Emacs.


File: racket-mode.info,  Node: Update,  Prev: Uninstall,  Up: Install Update and Uninstall

2.6 Update
==========

* Menu:

* Upgrading all packages::
* Updating just Racket Mode::


File: racket-mode.info,  Node: Upgrading all packages,  Next: Updating just Racket Mode,  Up: Update

2.6.1 Upgrading all packages
----------------------------

The “easy path” provided by Emacs is to update _all_ packages to their
latest versions.  Although you might not want to do this — see next
section — here is how to do so:

  1. Use ‘M-x’ ‘package-initialize’.

  2. Use ‘M-x’ ‘package-refresh-contents’.

  3. Use ‘M-x’ ‘list-packages’.  It should display a message like “42
     packages can be upgraded; type ‘U’ to mark them for upgrading.”.

  4. Press ‘U’ as suggested to mark them all.

  5. Press ‘x’ to execute.

   After such a mass update, it might be wise to exit and restart Emacs.

     NOTE: If you get an error message about “contacting a host” or
     “downloading an archive”, the problem is not unique to Racket Mode.
     Please see <https://melpa.org/#/getting-started>.


File: racket-mode.info,  Node: Updating just Racket Mode,  Prev: Upgrading all packages,  Up: Update

2.6.2 Updating just Racket Mode
-------------------------------

Updating all packages sometimes is more than you want.  For example,
maybe you will discover that some packages have changed in ways that
require you to take time to learn about, change customizations, and so
on.

   To update just Racket Mode:

  1. *note Uninstall::.

  2. Optional but most reliable: Exit and restart Emacs.

  3. *note Install:: again.  This will install the latest version.


File: racket-mode.info,  Node: Configure,  Next: Architecture,  Prev: Install Update and Uninstall,  Up: Top

3 Configure
***********

Although Racket Mode can be customized with many *note Variables::,
there is only one that you might _need_ to set: *note racket-program::.
This is the name or pathname of the Racket executable.  It defaults to
‘Racket.exe’ on Windows else ‘racket’.

   On Windows or Linux, this default will probably work for you.

   On macOS, downloading Racket doesn’t add its ‘bin’ directory to your
‘PATH’.  Even after you add it, GUI Emacs doesn’t automatically use your
path (unless you use the handy exec-path-from-shell
(https://melpa.org/#/exec-path-from-shell) package).  Therefore you
might want to set ‘racket-program’ to a complete pathname.

   You can ‘setq’ this directly in your Emacs init file (‘~/.emacs’ or
‘~/.emacs.d/init.el’), or, use ‘M-x’ ‘customize’, as you prefer.

* Menu:

* Which major mode to use::
* Key bindings::
* Font-lock (syntax highlighting)::
* Completion at point::
* Completion in minibuffer::
* Xref (definitions and references)::
* Indent::
* paredit::
* smartparens::
* Appearance of parentheses::
* Edit buffers and REPL buffers::
* eldoc::
* Start faster::
* Inserting Unicode math symbols::
* Ligatures::


File: racket-mode.info,  Node: Which major mode to use,  Next: Key bindings,  Up: Configure

3.1 Which major mode to use
===========================

Racket is a programming language.

   Racket is also a “language-oriented programming language”.  Most
Racket source files contain a ‘#lang‘ line.  The lang may be an
s-expression lang like ‘racket’, or an at-expression lang like
‘scribble/manual’, or something completely different like ‘datalog’ or
‘rhombus’.

   The Racket Mode package offers a choice of two major modes to use in
buffers for viewing and editing source code.  Each has pros and cons.

   Whereas ‘racket-mode’ is in the tradition of Emacs ‘lisp-mode’ and
‘scheme-mode’ and assumes s-expression langs, ‘racket-hash-lang-mode’
takes the approach of DrRacket to work for all langs.

   • ‘racket-mode’ is the original, “classic” mode for ‘#lang racket’
     and related s-expression languages.  It is implemented entirely in
     Emacs and does _not_ need Racket Mode’s back end racket process
     running.  Font-lock (coloring) uses rules for a fixed set of
     identifiers from ‘racket’ lang and popular modules like
     ‘racket/match’.  Indentation uses rules for a fixed set of forms,
     and may be customized.

   • ‘racket-hash-lang-mode’ uses font-lock (colors) and indentation
     determined by the lang; to get this information it _does_ need the
     Racket Mode’s back end racket process running.  Although basic
     editing should feel fast, you might notice some delay when
     indenting.  You might see colors appear after a small delay (but it
     will not block editing).  Speaking of colors, they will be
     “plainer” than ‘racket-mode’ – just colors for tokens like numbers,
     comments, strings, and keywords.  This looks similar to DrRacket.
     However you can enhance this in various ways; see the discussion of
     *note racket-hash-lang-module-language-hook::.

   You can use different major modes for different kinds of files:

   • For editing ‘.rkt’ files and s-expression langs, which mode to use
     is personal preference.

   • For ‘.scrbl’ files and at-expression langs like ‘scribble/manual’,
     ‘racket-hash-lang-mode’ is probably better than ‘racket-mode’.
     (Note there is also an unrelated ‘scribble-mode’ package.)

   • For non-s-expression langs like ‘datalog’ or ‘rhombus’ (‘.rhm’),
     ‘racket-hash-lang-mode’ is definitely better than ‘racket-mode’.
     (Note there is also an unrelated ‘rhombus-mode’ package.)

   You can use ‘auto-mode-alist’ to tell Emacs which major mode to use
initially for certain file extensions.  Also, in a buffer you can use
‘M-x racket-mode’ and ‘M-x racket-hash-lang-mode’ to switch between
them.


File: racket-mode.info,  Node: Key bindings,  Next: Font-lock (syntax highlighting),  Prev: Which major mode to use,  Up: Configure

3.2 Key bindings
================

To customize things like key bindings, you can use ‘racket-mode-hook’ in
your Emacs init file to modify ‘racket-mode-map’.  For example, although
‘C-c C-c’ is bound by default to the ‘racket-run’ command, let’s say you
wanted ‘F5’ to be an additional binding:

     (add-hook 'racket-mode-hook
               (lambda ()
                 (define-key racket-mode-map (kbd "<f5>") 'racket-run)))

   Likewise for ‘racket-repl-mode-hook’ and ‘racket-repl-mode-map’.


File: racket-mode.info,  Node: Font-lock (syntax highlighting),  Next: Completion at point,  Prev: Key bindings,  Up: Configure

3.3 Font-lock (syntax highlighting)
===================================

     Note: The alternative major mode *note racket-hash-lang-mode::
     disables all of the following behavior and uses colors determined
     by the #lang.

   Font-lock (as Emacs calls syntax highlighting) can be controlled
using the variable ‘font-lock-maximum-decoration’, which defaults to ‘t’
(maximum).  You can set it to a number, where ‘0’ is the lowest level.
You can even supply an association list to specify different values for
different major modes.

   Historically you might choose a lower level for speed.  These days
you might do so because you prefer a simpler appearance.

   Racket Mode supports four, increasing levels of font-lock:

   • ‘0’: Just strings, comments, and ‘#lang’.
   • ‘1’: ‘#:keyword’ and self-evaluating literals like numbers, quoted
     symbols (including symbols with spaces delimited by ‘|’
     characters), and ‘#rx’ and ‘#px’ regular expressions.
   • ‘2’: Identifiers in ‘define’-like and ‘let’-like forms.
   • ‘3’: Identifiers provided by ‘racket’, ‘typed/racket’,
     ‘racket/syntax’, and ‘syntax/parse’.  (This level effectively
     treats Racket as a language, instead of a language for making
     languages.).


File: racket-mode.info,  Node: Completion at point,  Next: Completion in minibuffer,  Prev: Font-lock (syntax highlighting),  Up: Configure

3.4 Completion at point
=======================

In Emacs, a major mode may supply a “completion-at-point function”.
This function is used by manual completion commands like
‘complete-symbol’ (bound by default to ‘C-M-i’ ), as well as by
auto-completion packages like ‘company-mode’.

   • ‘racket-mode’ supplies ‘racket-complete-at-point’, which simply
     supplies the same symbols that it knows how to font-lock.  This
     does _not_ require the Racket Mode back end to be running.  But of
     course the completion candidates do not correspond to your
     program’s definitions or those it imports.  This is a static,
     “better than nothing” fallback.

   • ‘racket-xp-mode’ — an optional minor mode that enhances
     ‘racket-mode’ — supplies ‘racket-xp-complete-at-point’, which uses
     a static analysis to find local and imported binding names.
     Although this requires the Racket Mode back end to be running — and
     will automatically start it — it does _not_ require the edit buffer
     to be ‘racket-run’.  This also supplies meta data usable by the
     ‘company-capf’ backend.

   • ‘racket-repl-mode’ supplies ‘racket-repl-complete-at-point’, which
     uses the result of ‘namespace-mapped-symbols’ on the program
     currently running in the REPL.

   These completion functions are set by default.  (However,
‘racket-xp-mode’ is not enabled by default.  To do so: *note
racket-xp-mode::.)

   If you want ‘TAB’ to do completion as well as indent, add the
following to your Emacs init file:

     (setq tab-always-indent 'complete)

   This changes the behavior of Emacs’ standard
‘indent-for-tab-command’, to which ‘TAB’ is bound by default in
‘racket-mode’ and ‘racket-repl-mode’.


File: racket-mode.info,  Node: Completion in minibuffer,  Next: Xref (definitions and references),  Prev: Completion at point,  Up: Configure

3.5 Completion in minibuffer
============================

Sometimes Racket Mode asks for input in the minibuffer.  To do so it
uses the standard Emacs function ‘completing-read’, so as to be
compatible with all Emacs packages that enhance ‘completing-read’, such
as helm, ivy, ido-completing-read+, vertico, and so on.

   (Earlier versions of Racket Mode sometimes used
‘ido-completing-read’.  If you have upgraded Racket Mode and miss that,
simply install the ido-completing-read+ package.)


File: racket-mode.info,  Node: Xref (definitions and references),  Next: Indent,  Prev: Completion in minibuffer,  Up: Configure

3.6 Xref (definitions and references)
=====================================

Several modes support the Emacs commands

   • ‘M-.’  ‘xref-find-definitions’
   • ‘M-?’  ‘xref-find-references’
   • ‘M-,’ ‘xref-pop-marker-stack’

   To do so, each mode adds a local hook for ‘xref-backend-functions’:

   • *note racket-mode::: ‘#'racket-mode-xref-backend-function’
   • *note racket-xp-mode::: ‘#'racket-xp-xref-backend-function’
   • *note racket-repl-mode::: ‘#'racket-repl-xref-backend-function’

   If you prefer, you can remove the local hook — e.g.  for
‘racket-mode’: ‘(remove-hook 'xref-backend-functions
#'racket-mode-xref-function t)’.

   You can ‘M-x customize-group’ and enter ‘xref’ to adjust some other
settings.  For example, the customization variable
‘xref-prompt-for-identifier’ controls which commands prompt you and
when.  You might prefer to set it to ‘nil’.

   If you use ‘paredit’, by default it binds ‘M-?’ to
‘paredit-convolute-sexp’.  You can change that binding in
‘paredit-mode-map’ allowing the global binding for ‘M-?’ to be used, or,
pick some other key for ‘xref-find-references’ in the global map.

   Finally, what to expect:

   • Racket does not have a global or project-wide database of
     definitions and references.
   • Various modules can export identifiers with the same symbolic value
     – for example a different “define” is provided by ‘racket/base’,
     ‘typed/racket/base’, and other modules.
   • A module can import something, then rename, contract, and re-export
     it.

   As a result, to find a definition, it is necessary to know exactly
_which_ identifier is meant — either by expanding the module (as is done
by ‘racket-xp-mode’) or by actually running it (‘racket-repl-mode’).
Once known, we can usually find the definition site, even through a
chain of renaming and/or contract-wrapping exports.  In addition, when
point is on a module within ‘require’ form, we can usually find the
source file.  (In plain ‘racket-mode’ edit buffers not enhanced by
‘racket-xp-mode’, the only thing that ‘xref-find-definitions’ does is
visit relative requires, e.g.  ‘foo.rkt’ in ‘(require "foo.rkt")’.)

   As for finding references, the default xref implementation is used,
which greps for strings among a project’s files.  Although
‘racket-xp-mode’ can sometimes do better, using ‘drracket/check-syntax’
for definitions and references _within_ the current buffer, beyond those
it also falls back to the default implementation.

   In any case, using the Emacs xref API allows for consistent command
names, shortcut keys, and even a special buffer to navigate among
references and visit each source location.


File: racket-mode.info,  Node: Indent,  Next: paredit,  Prev: Xref (definitions and references),  Up: Configure

3.7 Indent
==========

     Note: The alternative major mode *note racket-hash-lang-mode::
     disables all of the following behavior and uses indentation
     determined by the #lang.

   Indentation can be customized in a way similar to lisp-mode and
scheme-mode: *note racket-indent-line::.

   (Indentation preserves your line breaks.  If you want to use an
auto-reformatter — an expressive pretty printer that chooses line breaks
while computing an optimal layout — the Racket package fmt
(https://docs.racket-lang.org/fmt/) is supported by the Emacs package
emacs-format-all-the-code
(https://github.com/lassik/emacs-format-all-the-code).)


File: racket-mode.info,  Node: paredit,  Next: smartparens,  Prev: Indent,  Up: Configure

3.8 paredit
===========

     Note: If you use *note racket-hash-lang-mode::, see *note
     racket-hash-lang-module-language-hook:: for how to enable/disable
     paredit based on the specific #lang.

   If you use paredit (https://melpa.org/#/paredit), you might want to
add keybindings to ‘paredit-mode-map’:

   • Bind the curly brace keys to ‘paredit-open-curly’ and
     ‘paredit-close-curly’.

   • Bind whatever keys you prefer for ‘paredit-wrap-square’ and
     ‘paredit-wrap-curly’.

   For example, with ‘use-package’ (https://melpa.org/#/use-package):

     (use-package paredit
       :ensure t
       :config
       (dolist (m '(emacs-lisp-mode-hook
                    racket-mode-hook
                    racket-repl-mode-hook))
         (add-hook m #'paredit-mode))
       (bind-keys :map paredit-mode-map
                  ("{"   . paredit-open-curly)
                  ("}"   . paredit-close-curly))
       (unless terminal-frame
         (bind-keys :map paredit-mode-map
                    ("M-[" . paredit-wrap-square)
                    ("M-{" . paredit-wrap-curly))))

   Starting c.  November 2022, paredit binds the ‘RET’ key to its own
command.  Unfortunately this is _not_ compatible with interactive modes
— including but not limited to ‘racket-repl-mode’ — which expect ‘RET’
to be bound to a command to submit your input to the REPL.  In other
words, if you type an expression and hit ‘RET’ , nothing will happen and
the REPL will seem frozen.  You ‘M-x racket-repl-submit’ to proceed.

   If you want to use paredit with interactive modes, their advice is to
remove the binding from ‘paredit-mode-map’ (note that this will also
disable it for all buffers, including editing buffers).  One way you can
do this for all related keys:

     (dolist (k '("RET" "C-m" "C-j"))
       (define-key paredit-mode-map (kbd k) nil))


File: racket-mode.info,  Node: smartparens,  Next: Appearance of parentheses,  Prev: paredit,  Up: Configure

3.9 smartparens
===============

     Note: If you use *note racket-hash-lang-mode::, see *note
     racket-hash-lang-module-language-hook:: for how to enable/disable
     smartparens based on the specific #lang.

   If instead of paredit you prefer smartparens
(https://melpa.org/#/smartparens), you can use the default configuration
it provides for Lisp modes generally and for Racket Mode specifically:

     (require 'smartparens-config)


File: racket-mode.info,  Node: Appearance of parentheses,  Next: Edit buffers and REPL buffers,  Prev: smartparens,  Up: Configure

3.10 Appearance of parentheses
==============================

If you prefer parentheses to appear “dimmed”, see paren-face
(https://melpa.org/#/paren-face).

   If you prefer the opposite, see rainbow-delimiters
(https://melpa.org/#/rainbow-delimiters).


File: racket-mode.info,  Node: Edit buffers and REPL buffers,  Next: eldoc,  Prev: Appearance of parentheses,  Up: Configure

3.11 Edit buffers and REPL buffers
==================================

By default, all ‘racket-mode’ edit buffers share one ‘racket-repl-mode’
buffer, named ‘*Racket REPL*’.  For example, if you run foo.rkt, the
REPL prompt changes to ‘foo.rkt>’, and the REPL is inside the file
module namespace.  If you then run bar.rkt, the REPL prompt changes to
‘bar.rkt>’, and you are in that namespace.

   If you prefer, you can use more than one REPL buffer, by customizing
the variable *note racket-repl-buffer-name-function:::

   • Share a REPL buffer among files belonging to the same project; each
     REPL buffer is named ‘*Racket REPL <project-name>*’.
   • A unique REPL buffer for each edit buffer, similar to Dr Racket;
     each REPL buffer is named ‘*Racket REPL <file.rkt>*’.
   • You can also define your own, custom function.

   You can customize where the REPL buffer is displayed by adding an
item to the Emacs variable ‘display-buffer-alist’.  A good regular
expression to use for this would be ‘\\`\\*Racket REPL’.  For example,
if you wanted to make the REPL buffer appear in a new frame:

     (add-to-list 'display-buffer-alist
                  '("\\`\\*Racket REPL"
                    (display-buffer-reuse-window
                     display-buffer-pop-up-frame)
                    (reusable-frames . 0)
                    (inhibit-same-window . t)))


File: racket-mode.info,  Node: eldoc,  Next: Start faster,  Prev: Edit buffers and REPL buffers,  Up: Configure

3.12 eldoc
==========

Various modes add local hooks to ‘eldoc-documentation-functions’.

   • The minor mode ‘racket-xp-mode’ adds hooks to document the
     identifiers at point or at an apparent s-expression application
     head position.  The identifiers are documented from check-syntax
     annotations.  You may customize the variable *note
     racket-xp-eldoc-level:: to choose how much information is shown.

   • The major mode ‘racket-repl-mode’ adds hooks to describe the
     namespace identifers at point or at an apparent s-expression
     application head position.  The description is a signature from
     surface syntax, or a Typed Racket type, or a “bluebox” for the
     namespace identifier.

   Tip: With an ‘eldoc-documentation-strategy’ of
‘eldoc-documentation-default’, these hooks show info about point when
available, _or else_ for the s-expression application head.  You may
change that to ‘eldoc-documentation-compose’ to show info for _both_
positions when available.

   Tip: Some people use the third-party package ‘eldoc-box’ to show
information in a child frame (near point, or in a corner of the main
frame) instead of the echo area.

   Note: Racket Mode does not support the “old” eldoc API that uses
‘eldoc-documentation-function’, singular.


File: racket-mode.info,  Node: Start faster,  Next: Inserting Unicode math symbols,  Prev: eldoc,  Up: Configure

3.13 Start faster
=================

You can use *note racket-mode-start-faster:: to make the Racket REPL
start faster.


File: racket-mode.info,  Node: Inserting Unicode math symbols,  Next: Ligatures,  Prev: Start faster,  Up: Configure

3.14 Inserting Unicode math symbols
===================================

To insert various Unicode math symbols, you can:

   • Use a command: *Note racket-insert-symbol::.

   • Use an Emacs input method, which you can enable in a buffer using a
     minor mode: *Note racket-input-mode::.


File: racket-mode.info,  Node: Ligatures,  Prev: Inserting Unicode math symbols,  Up: Configure

3.15 Ligatures
==============

Prior to Emacs 28.0.50, things like ‘auto-composition-mode’ or
‘ligature-mode’ that use ‘composition-function-table’ to display
ligatures can cause Emacs to freeze.  This can happen when an Emacs
_overlay_ displays a string containing such a ligature.  Although the
problem is not limited to Racket Mode, it affects the overlays created
by ‘racket-show-pseudo-tooltip’, as used by ‘racket-xp-mode’.  The only
known work-around is to change the value of ‘racket-show-functions’ to
something “boring” such as ‘(racket-show-echo-area)’.


File: racket-mode.info,  Node: Architecture,  Next: Reference,  Prev: Configure,  Up: Top

4 Architecture
**************

Racket Mode consists of a single Emacs front end, and one or more
processes running a back end written in Racket.(1)

   A back end is responsible for commands that cannot be implemented in
Emacs Lisp, as well as supplying zero or more REPLs.

   Although you can start and stop a back end with
‘racket-start-back-end’ and ‘racket-stop-back-end’, a back end is
normally started automatically when the front end needs to issue some
command.  This includes commands that do _not_ involve ‘racket-run’ or a
REPL.  For example ‘racket-xp-mode’ issues commands to check your code
and annotate the buffer, even if you do not run it.  In other words, a
back end supplies zero or more REPLs — a back end is not the same thing
as a REPL.

   To learn more about how _many_ REPLs are used: *Note
racket-repl-buffer-name-function::.

   In the common case there is only one back end, on the same local host
as Emacs, and it is used for ‘.rkt’ files in any directory.

[Emacs front end and one local back end. Command I/O via pipe (local) or ssh (remote). Each back end provides zero or more REPLs.]

   However you can configure using any number of back ends on any number
of local or remote host paths.

   As one example, you can have multiple back ends on the local host.
One back end is used for a project under a specific subdirectory, and
the other back end for all others.  (Perhaps one project needs Racket
built from source, and everything else uses an installed, older version
of Racket.  By using different back ends, not only will ‘racket-run’ use
the desired version of Racket for a file, so will commands for
documentation or visiting definitions.)

[Emacs front end and two local back ends -- one for a project path. Command I/O via pipe (local) or ssh (remote). Each back end provides zero or more REPLs.]

   (Note: If you use various versions of Racket via ‘direnv’
(https://direnv.net/) combined with the ‘envrc’ Emacs package
(https://github.com/purcell/envrc), you still need a distinct back end
for each project.  To arrange this, add or modify a ‘.dir-locals.el’
file next to each ‘.envrc’ file; *Note racket-add-back-end::.)

   Furthermore, you could work with a project located on a remote host,
whose files you edit using TRAMP.  You also want the back end to run
there.  For a remote host, Racket Mode copies its back end source files
to the remote when necessary, and runs the back end using ssh.

[Emacs front end and a back end on a remote host. Command I/O via pipe (local) or ssh (remote). Each back end provides zero or more REPLs.]

   Of course the remote can also use different back ends for different
paths.

[Emacs front end and two back ends on a remote host. Command I/O via pipe (local) or ssh (remote). Each back end provides zero or more REPLs.]

   And of course you can have multiple remotes.

[Emacs front end and two back ends each on two remote hosts. Command I/O via pipe (local) or ssh (remote). Each back end provides zero or more REPLs.]

   If you need any of these “fancy” configurations: *Note
racket-add-back-end::.

   However by default a configuration is automatically created for one
back end on the local host.  For that very common case, you don’t need
to configure anything.

   ---------- Footnotes ----------

   (1) Racket Mode’s Racket code is delivered as part of the Emacs
package — _not_ as a Racket package.  Delivering both Emacs and Racket
code in one Emacs package simplifies installation and updates.  The main
drawback is that the Racket code is not automatically compiled, as would
normally be done by ‘raco pkg install’.  To address this: *Note
racket-mode-start-faster::.


File: racket-mode.info,  Node: Reference,  Next: Commands,  Prev: Architecture,  Up: Top

5 Reference
***********

The following sections are generated from the doc strings for each
command, variable, or face.  (As a result, some of the formatting might
not be quite as nice or correct as in the previous sections.)

   You can also view these by using the normal Emacs help mechanism:

   • ‘C-h f’ and enter the name of a command.
   • ‘C-h v’ and enter the name of a variable.


File: racket-mode.info,  Node: Commands,  Next: Variables,  Prev: Reference,  Up: Top

6 Commands
**********

* Menu:

* Edit::
* Hash Langs::
* Explore::
* Run::
* Test::
* Eval::
* Collections::
* Macro expand::
* Packages::
* Debug::
* Other::


File: racket-mode.info,  Node: Edit,  Next: Hash Langs,  Up: Commands

6.1 Edit
========

* Menu:

* racket-mode::
* racket-insert-lambda::
* racket-insert-symbol::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-add-require-for-identifier::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-input-mode::
* racket-align::
* racket-unalign::
* racket-complete-at-point::


File: racket-mode.info,  Node: racket-mode,  Next: racket-insert-lambda,  Up: Edit

6.1.1 racket-mode
-----------------

‘M-x’ ‘racket-mode’

   The “classic” major mode to edit an s-expression Racket #lang.

   This major mode is implemented entirely in Emacs and does _not_ need
Racket Mode’s back end racket process to be running.  Font-lock
(coloring) uses rules for a fixed set of identifiers from ‘racket’ lang
and popular modules like ‘racket/match’.  Indentation uses rules for a
fixed set of forms, and may be customized.

   See also *note racket-hash-lang-mode::.

Key                                                                                                                                     Binding
‘C-c C-c’ or ‘C-c C-k’                                                                                                                  *note racket-run-module-at-point::
‘C-c C-z’                                                                                                                               ‘racket-edit-switch-to-repl’
‘C-c C-t’                                                                                                                               *note racket-test::
‘C-c C-l’                                                                                                                               *note racket-logger::
‘C-c C-o’                                                                                                                               *note racket-profile::
‘C-c C-r’                                                                                                                               *note racket-send-region::
‘C-c C-e f’                                                                                                                             *note racket-expand-file::
‘C-c C-e x’                                                                                                                             *note racket-expand-definition::
‘C-c C-e e’                                                                                                                             *note racket-expand-last-sexp::
‘C-c C-e r’                                                                                                                             *note racket-expand-region::
‘C-c C-x C-f’                                                                                                                           *note racket-open-require-path::
‘C-c C-p’                                                                                                                               *note racket-cycle-paren-shapes::
‘C-c C-d’                                                                                                                               *note racket-documentation-search::
‘C-c C-s’ or ‘C-c C-.’                                                                                                                  *note racket-describe-search::
‘C-c C-f’                                                                                                                               *note racket-fold-all-tests::
‘C-c C-u’                                                                                                                               *note racket-unfold-all-tests::
‘C-M-x’                                                                                                                                 *note racket-send-definition::
‘C-M-u’                                                                                                                                 *note racket-backward-up-list::
‘C-M-y’                                                                                                                                 *note racket-insert-lambda::
‘C-x C-e’                                                                                                                               *note racket-send-last-sexp::
‘TAB’                                                                                                                                   ‘indent-for-tab-command’
‘)’ or ‘]’ or ‘}’                                                                                                                       *note racket-insert-closing::

   In addition to any hooks its parent mode ‘prog-mode’ might have run,
this mode runs the hook ‘racket-mode-hook’, as the final or penultimate
step during initialization.


File: racket-mode.info,  Node: racket-insert-lambda,  Next: racket-insert-symbol,  Prev: racket-mode,  Up: Edit

6.1.2 racket-insert-lambda
--------------------------

‘C-M-y’

   Insert λ.

   To insert Unicode symbols generally, see *note racket-input-mode::.


File: racket-mode.info,  Node: racket-insert-symbol,  Next: racket-fold-all-tests,  Prev: racket-insert-lambda,  Up: Edit

6.1.3 racket-insert-symbol
--------------------------

‘M-x’ ‘racket-insert-symbol’

   Insert a symbol from *note racket-input-translations::.

   A command alternative to the “Racket” input method activated by *note
racket-input-mode::.

   Presents a ‘completing-read’ UI, in which the symbols that would be
inserted are shown as annotations – a preview unlike what is currently
provided by the Emacs UI for input method.


File: racket-mode.info,  Node: racket-fold-all-tests,  Next: racket-unfold-all-tests,  Prev: racket-insert-symbol,  Up: Edit

6.1.4 racket-fold-all-tests
---------------------------

‘C-c C-f’

   Fold (hide) all test submodules.


File: racket-mode.info,  Node: racket-unfold-all-tests,  Next: racket-tidy-requires,  Prev: racket-fold-all-tests,  Up: Edit

6.1.5 racket-unfold-all-tests
-----------------------------

‘C-c C-u’

   Unfold (show) all test submodules.


File: racket-mode.info,  Node: racket-tidy-requires,  Next: racket-trim-requires,  Prev: racket-unfold-all-tests,  Up: Edit

6.1.6 racket-tidy-requires
--------------------------

‘M-x’ ‘racket-tidy-requires’

   Make a single, sorted “require” form for each module.

   Use a single require-spec for each phase-level, sorted in this order:
for-syntax, for-template, for-label, for-meta, and plain (phase 0).

   Within each phase-level, sort require-specs by module name.

   Format at most one module per line.

   Simplify gratuitous require-specs.  For example reduce (only-in m) to
m and elide (combine-in).

   See also: *note racket-trim-requires:: and *note
racket-base-requires::.


File: racket-mode.info,  Node: racket-trim-requires,  Next: racket-base-requires,  Prev: racket-tidy-requires,  Up: Edit

6.1.7 racket-trim-requires
--------------------------

‘M-x’ ‘racket-trim-requires’

   Like *note racket-tidy-requires:: but also delete unnecessary
requires.

   Use macro-debugger/analysis/check-requires to analyze.

   The analysis:

   • Needs the ‘macro-debugger-lib’ package.

   • Only works when the source file can be fully expanded with no
   errors.

   • Only works for requires at the top level of a source file using
   #lang – not for requires inside submodule forms.  Furthermore, the
analysis is not smart about module+ or module* forms – it might delete
outer requires that are actually needed by such submodules.

   See also: *note racket-base-requires::.


File: racket-mode.info,  Node: racket-base-requires,  Next: racket-add-require-for-identifier,  Prev: racket-trim-requires,  Up: Edit

6.1.8 racket-base-requires
--------------------------

‘M-x’ ‘racket-base-requires’

   Change from “#lang racket” to “#lang racket/base”.

   Using “racket/base” is a recommended optimization for Racket
applications.  Loading all of “racket” is slower and uses more memory.

   Add explicit requires for imports that are provided by “racket” but
not by “racket/base”.

   Also do the equivalent of *note racket-trim-requires:: and ‘nil’.
See those commands for additional notes and caveats.

   Note: Currently this only helps change “#lang racket” to “#lang
racket/base”.  It does not help with other similar conversions, such as
changing “#lang typed/racket” to “#lang typed/racket/base”.


File: racket-mode.info,  Node: racket-add-require-for-identifier,  Next: racket-indent-line,  Prev: racket-base-requires,  Up: Edit

6.1.9 racket-add-require-for-identifier
---------------------------------------

‘M-x’ ‘racket-add-require-for-identifier’

   Add a require for an identifier.

   Useful when you know the name of an export but don’t remember from
what module it is exported.

   After you choose an identifier, this command will:

   • Insert the identifier at point if not already there.

   • Insert a “require” form and do *note racket-tidy-requires::.

   Caveat: This works only for identifiers that are documented.  The
mechanism is similar to that used for Racket’s “Search Manuals” feature.
Today there exists no system-wide database of identifiers that are
exported but not documented.


File: racket-mode.info,  Node: racket-indent-line,  Next: racket-smart-open-bracket-mode,  Prev: racket-add-require-for-identifier,  Up: Edit

6.1.10 racket-indent-line
-------------------------

‘M-x’ ‘racket-indent-line’

   Indent current line as Racket code.

   Normally you don’t invoke this command directly.  Instead, because it
is used as the value for the variable ‘indent-line-function’ in *note
racket-mode:: and *note racket-repl-mode:: buffers, it is used
automatically when you press keys like RET or TAB.  However you might
refer to it when configuring custom indentation, explained below.

   Following the tradition of ‘lisp-mode’ and ‘scheme-mode’, the primary
way to determine the indentation of a form is to look for a rule stored
as a ‘racket-indent-function’ property.

   To extend, use your Emacs init file to

         (put SYMBOL 'racket-indent-function INDENT)

   SYMBOL is the name of the Racket form like “test-case” and INDENT is
an integer or the symbol “defun”.  When INDENT is an integer, the
meaning is the same as for lisp-indent-function and
scheme-indent-function: Indent the first INDENT arguments specially and
indent any further arguments like a body.  (The number may be negative;
see discussion below.)

   For example:

         (put 'test-case 'racket-indent-function 1)

   This will change the indent of ‘test-case’ from this:

         (test-case foo
                    blah
                    blah)

   to this:

         (test-case foo
           blah
           blah)

   For backward compatibility, if ‘racket-indent-function’ has no
property for a symbol, a scheme-indent-function property is also
considered, although the “with-” indents defined by scheme-mode are
ignored.  This is only to help people who may have extensive
scheme-indent-function settings, particularly in the form of file or dir
local variables.  Otherwise prefer putting properties on
‘racket-indent-function’.

   If no explicit rules match, regular expressions are used for a couple
special cases:

   • Forms that start with “begin” indent like “begin”.

   • Forms that start with “def” or “with-” indent like “define”.

   On the one hand this is convenient when you create your own “DRY”
macros; they will indent as expected without you needing to make custom
indent rules.  On the other hand there can be false matches; for example
a function or form named “defer” will indent like “define”.  This is a
known drawback and is unlikely to be fixed unless/until Racket macros
someday support a protocol to communicate how they should be indented.

   There is also automatic handling for:

   • Forms that begin with a #:keyword (as found in contracts)

   • Literal forms like #hasheq()

   • Quoted forms when the variable *note racket-indent-sequence-depth::
     is > 0.

   • {} forms when the variable *note racket-indent-curly-as-sequence::
     is not nil.

   Finally and otherwise, a form will be indented as if it were a
procedure application.

   — — —

   Note: Racket Mode extends the traditional Emacs lisp indent spec to
allow a _negative_ integer, which means that all distinguished forms
should align with the first one.  This style originated with “for/fold”,
which has two distinguished forms.  Traditionally those would indent
like this:

         (for/fold ([x xs])
             ([y ys])            ; twice body indent
           body)

   However the popularly desired indent is:

         (for/fold ([x xs])
                   ([y ys])      ; same as first distingushed form
           body)

   This idea extends to optional distinguished forms, such as Typed
Racket annotation “prefixes” in “for/fold”, “for/x”, and even “let”
forms:

         (for/fold : Type
                   ([x xs])
                   ([y ys])      ; same as first distingushed form
           body)


File: racket-mode.info,  Node: racket-smart-open-bracket-mode,  Next: racket-insert-closing,  Prev: racket-indent-line,  Up: Edit

6.1.11 racket-smart-open-bracket-mode
-------------------------------------

‘M-x’ ‘racket-smart-open-bracket-mode’

   Minor mode to let you always type ‘[’’ to insert ‘(’ or ‘[’
automatically.

   Behaves like the “Automatically adjust opening square brackets”
feature in Dr.  Racket.

   By default, inserts a ‘(’.  Inserts a ‘[’ in the following cases:

   • ‘let’-like bindings – forms with ‘let’ in the name as well as
     things like ‘parameterize’, ‘with-handlers’, and ‘with-syntax’.

   • ‘case’, ‘cond’, ‘match’, ‘syntax-case’, ‘syntax-parse’, and
     ‘syntax-rules’ clauses.

   • ‘for’-like bindings and ‘for/fold’ accumulators.

   • ‘class’ declaration syntax, such as ‘init’ and ‘inherit’.

   When the previous s-expression in a sequence is a compound
expression, uses the same kind of delimiter.

   To force insert ‘[’, use ‘quoted-insert’.

   Combined with *note racket-insert-closing:: this means that you can
press the unshifted ‘[’ and ‘]’ keys to get whatever delimiters follow
the Racket conventions for these forms.  When something like
‘electric-pair-mode’ or ‘paredit-mode’ is active, you need not even
press ‘]’.

   Tip: When also using ‘paredit-mode’, enable that first so that the
binding for the ‘[’’ key in the map for *note
racket-smart-open-bracket-mode:: has higher priority.  See also the
variable ‘minor-mode-map-alist’.

   Tip: When using this with *note racket-hash-lang-mode::, you may want
to use *note racket-hash-lang-module-language-hook:: to enable it IFF
the module langugage is something like “racket”.

   This is a minor mode.  If called interactively, toggle the
‘Racket-Smart-Open-Bracket mode’ mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable the
mode.

   If called from Lisp, toggle the mode if ARG is ‘toggle’.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

   To check whether the minor mode is enabled in the current buffer,
evaluate the variable *note racket-smart-open-bracket-mode::.

   The mode’s hook is called both when the mode is enabled and when it
is disabled.


File: racket-mode.info,  Node: racket-insert-closing,  Next: racket-cycle-paren-shapes,  Prev: racket-smart-open-bracket-mode,  Up: Edit

6.1.12 racket-insert-closing
----------------------------

‘]’ or ‘)’

   Insert a matching closing delimiter.

   With ‘C-u’ insert the typed character as-is.

   This is handy if you’re not yet using something like ‘paredit-mode’,
‘smartparens-mode’, ‘parinfer-mode’, or simply ‘electric-pair-mode’
added in Emacs 24.5.


File: racket-mode.info,  Node: racket-cycle-paren-shapes,  Next: racket-backward-up-list,  Prev: racket-insert-closing,  Up: Edit

6.1.13 racket-cycle-paren-shapes
--------------------------------

‘C-c C-p’

   Cycle the sexpr among () [] {}.


File: racket-mode.info,  Node: racket-backward-up-list,  Next: racket-input-mode,  Prev: racket-cycle-paren-shapes,  Up: Edit

6.1.14 racket-backward-up-list
------------------------------

‘C-M-u’

   Like ‘backward-up-list’ but works when point is in a string or
comment.

   Typically you should not use this command in Emacs Lisp – especially
not repeatedly.  Instead, initially use
‘racket--escape-string-or-comment’ to move to the start of a string or
comment, if any, then use normal ‘backward-up-list’ repeatedly.


File: racket-mode.info,  Node: racket-input-mode,  Next: racket-align,  Prev: racket-backward-up-list,  Up: Edit

6.1.15 racket-input-mode
------------------------

‘M-x’ ‘racket-input-mode’

   A minor mode to enable the “Racket” input method.

   The Racket input method lets you type *note racket-input-prefix::,
followed by a key sequence from *note racket-input-translations::,
directly in a buffer, to insert a symbol.

   For example when *note racket-input-prefix:: is the default “\”, you
can type “\All” and it is immediately replaced with “∀”.

   To enable *note racket-input-mode:: (and the Racket input method) for
all new buffers, put the following in your Emacs init file:

         (dolist (hook '(racket-mode-hook
                         racket-hash-lang-mode-hook
                         racket-repl-mode-hook))
           (add-hook hook #'racket-input-mode))

   Tip: You may use the standard Emacs key C-\ to toggle the current
input method.

   Tip: If you don’t like the highlighting of partially matching tokens
you can disable that using ‘input-method-highlight-flag’.

   See the Emacs manual for other information about input methods.

   Tip: Another way to use *note racket-input-translations:: is by using
a command: *note racket-insert-symbol::.

   This is a minor mode.  If called interactively, toggle the
‘Racket-Input mode’ mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

   If called from Lisp, toggle the mode if ARG is ‘toggle’.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

   To check whether the minor mode is enabled in the current buffer,
evaluate the variable *note racket-input-mode::.

   The mode’s hook is called both when the mode is enabled and when it
is disabled.


File: racket-mode.info,  Node: racket-align,  Next: racket-unalign,  Prev: racket-input-mode,  Up: Edit

6.1.16 racket-align
-------------------

‘M-x’ ‘racket-align’

   Align values in the same column.

   Useful for binding forms like “let” and “parameterize”, conditionals
like “cond” and “match”, association lists, and any series of couples
like the arguments to “hash”.

   Before choosing this command, put point on the first of a series of
“couples”.  A couple is:

   • A list of two or more sexprs: “[sexpr val sexpr ...]”.
   • Two sexprs: “sexpr val”.

   Each “val” moves to the same column and is ‘prog-indent-sexp’-ed (in
case it is a multi-line form).

   For example with point on the “[” before “a”:

         Before             After

         (let ([a 12]       (let ([a   12]
               [bar 23])          [bar 23])
           ....)              ....)

         ([a . 12]          ([a   . 12]
          [bar . 23])        [bar . 23])

         (cond [a? #t]      (cond [a?   #t]
               [b? (f x           [b?   (f x
                      y)]                  y)]
               [else #f])         [else #f])

   Or with point on the quote before “a”:

         (list a 12        (list a   12
               bar 23)           bar 23)

   If more than one couple is on the same line, none are aligned,
because it is unclear where the value column should be.  For example the
following form will not change; *note racket-align:: will display an
error message:

         (let ([a 0][b 1]
               [c 2])       error; unchanged
           ....)

   When a couple’s sexprs start on different lines, that couple is
ignored.  Other, single-line couples in the series are aligned as usual.
For example:

         (let ([foo         (let ([foo
                0]                 0]
               [bar 1]            [bar 1]
               [x 2])             [x   2])
           ....)              ....)

   See also: *note racket-unalign::.


File: racket-mode.info,  Node: racket-unalign,  Next: racket-complete-at-point,  Prev: racket-align,  Up: Edit

6.1.17 racket-unalign
---------------------

‘M-x’ ‘racket-unalign’

   The opposite of *note racket-align::.

   Effectively does M-x ‘just-one-space’ and ‘prog-indent-sexp’ for each
couple’s value.


File: racket-mode.info,  Node: racket-complete-at-point,  Prev: racket-unalign,  Up: Edit

6.1.18 racket-complete-at-point
-------------------------------

A value for the variable ‘completion-at-point-functions’.

   Completion candidates are drawn from the same symbols used for
font-lock.  This is a static list.  If you want dynamic, smarter
completion candidates, enable the minor mode *note racket-xp-mode::.


File: racket-mode.info,  Node: Hash Langs,  Next: Explore,  Prev: Edit,  Up: Commands

6.2 Hash Langs
==============

* Menu:

* racket-hash-lang-mode::
* racket-hash-lang-backward::
* racket-hash-lang-forward::
* racket-hash-lang-up::
* racket-hash-lang-down::
* racket-hash-lang-C-M-q-dwim::


File: racket-mode.info,  Node: racket-hash-lang-mode,  Next: racket-hash-lang-backward,  Up: Hash Langs

6.2.1 racket-hash-lang-mode
---------------------------

‘M-x’ ‘racket-hash-lang-mode’

   An “experimental” major mode to edit any Racket #lang.

   This major mode uses color-lexer, indent, and navigation supplied by
each #lang – which means Racket Mode’s back end process needs to be
running.

   In your Emacs configuration, you may want to update the variable
‘auto-mode-alist’ to use *note racket-hash-lang-mode:: for file
extensions like “.rkt”, “.scrbl”, and/or “.rhm”.

   Languages supply colors for lexer tokens like strings and comments;
see the customization variable *note
racket-hash-lang-token-face-alist::.  For more colors see the hook
variable *note racket-hash-lang-module-language-hook::, which can also
be used to vary configurations per language.

   A discussion of the information provided by a Racket language:

   <https://docs.racket-lang.org/tools/lang-languages-customization.html>

Key                                                                                                              Binding
‘C-c C-c’ or ‘C-c C-k’                                                                                           *note racket-run-module-at-point::
‘C-c C-z’                                                                                                        ‘racket-edit-switch-to-repl’
‘C-c C-t’                                                                                                        *note racket-test::
‘C-c C-l’                                                                                                        *note racket-logger::
‘C-c C-o’                                                                                                        *note racket-profile::
‘C-c C-r’                                                                                                        *note racket-send-region::
‘C-c C-e f’                                                                                                      *note racket-expand-file::
‘C-c C-e x’                                                                                                      *note racket-expand-definition::
‘C-c C-e e’                                                                                                      *note racket-expand-last-sexp::
‘C-c C-e r’                                                                                                      *note racket-expand-region::
‘C-c C-x C-f’                                                                                                    *note racket-open-require-path::
‘C-c C-f’                                                                                                        *note racket-fold-all-tests::
‘C-c C-u’                                                                                                        *note racket-unfold-all-tests::
‘C-M-x’                                                                                                          *note racket-send-definition::
‘C-M-y’                                                                                                          *note racket-insert-lambda::
‘C-M-b’                                                                                                          *note racket-hash-lang-backward::
‘C-M-f’                                                                                                          *note racket-hash-lang-forward::
‘C-M-u’                                                                                                          *note racket-hash-lang-up::
‘C-M-d’                                                                                                          *note racket-hash-lang-down::
‘C-M-q’                                                                                                          *note racket-hash-lang-C-M-q-dwim::
‘C-x C-e’                                                                                                        *note racket-send-last-sexp::
‘TAB’                                                                                                            ‘racket-hash-lang-indent’
‘RET’                                                                                                            ‘newline-and-indent’

   In addition to any hooks its parent mode ‘prog-mode’ might have run,
this mode runs the hook ‘racket-hash-lang-mode-hook’, as the final or
penultimate step during initialization.


File: racket-mode.info,  Node: racket-hash-lang-backward,  Next: racket-hash-lang-forward,  Prev: racket-hash-lang-mode,  Up: Hash Langs

6.2.2 racket-hash-lang-backward
-------------------------------

‘C-M-b’

   Like ‘backward-sexp’ but uses #lang supplied navigation.


File: racket-mode.info,  Node: racket-hash-lang-forward,  Next: racket-hash-lang-up,  Prev: racket-hash-lang-backward,  Up: Hash Langs

6.2.3 racket-hash-lang-forward
------------------------------

‘C-M-f’

   Like ‘forward-sexp’ but uses #lang supplied navigation.


File: racket-mode.info,  Node: racket-hash-lang-up,  Next: racket-hash-lang-down,  Prev: racket-hash-lang-forward,  Up: Hash Langs

6.2.4 racket-hash-lang-up
-------------------------

‘C-M-u’

   Like ‘backward-up-list’ but uses #lang supplied navigation.


File: racket-mode.info,  Node: racket-hash-lang-down,  Next: racket-hash-lang-C-M-q-dwim,  Prev: racket-hash-lang-up,  Up: Hash Langs

6.2.5 racket-hash-lang-down
---------------------------

‘C-M-d’

   Like ‘down-list’ but uses #lang supplied navigation.


File: racket-mode.info,  Node: racket-hash-lang-C-M-q-dwim,  Prev: racket-hash-lang-down,  Up: Hash Langs

6.2.6 racket-hash-lang-C-M-q-dwim
---------------------------------

‘C-M-q’

   Fill or indent depending on lang lexer’s token at point.

   When the lang lexer token is...

   • “text”, for example in Scribble document text, do ‘fill-paragraph’.

   • “comment”, do ‘fill-comment’.

   • “whitespace”, give an error message.

   • anything else, do ‘prog-indent-sexp’.


File: racket-mode.info,  Node: Explore,  Next: Run,  Prev: Hash Langs,  Up: Commands

6.3 Explore
===========

* Menu:

* racket-xp-mode::
* racket-xp-describe::
* racket-xp-documentation::
* racket-xp-next-definition::
* racket-xp-previous-definition::
* racket-xp-next-use::
* racket-xp-previous-use::
* racket-xp-next-error::
* racket-xp-previous-error::
* racket-xp-tail-up::
* racket-xp-tail-down::
* racket-xp-tail-next-sibling::
* racket-xp-tail-previous-sibling::
* racket-documentation-search::
* racket-describe-mode::
* racket-describe-search::


File: racket-mode.info,  Node: racket-xp-mode,  Next: racket-xp-describe,  Up: Explore

6.3.1 racket-xp-mode
--------------------

‘M-x’ ‘racket-xp-mode’

   A minor mode that analyzes expanded code to explain and explore.

   This minor mode is an optional enhancement to *note racket-mode::
edit buffers.  Like any minor mode, you can turn it on or off for a
specific buffer.  If you always want to use it, put the following code
in your Emacs init file:

         (require 'racket-xp)
         (add-hook 'racket-mode-hook #'racket-xp-mode)

   Note: This mode won’t do anything unless/until the Racket Mode back
end is running.  It will try to start the back end automatically.  You
do _not_ need to *note racket-run:: the buffer you are editing.

   This mode uses the drracket/check-syntax package to analyze
fully-expanded programs, without needing to evaluate a.k.a.  “run” them.
The resulting analysis provides information for:

   • Visually annotating bindings – local or imported definitions and
     references to them.

   • Visually annotating expressions in a tail position, as well as the
     enclosing expression with respect to which they are in a tail
     position.

   • Completion candidates.

   • Defintions’ source and documentation.

   When point is on a definition or use, related items are highlighted
using *note racket-xp-def-face:: and *note racket-xp-use-face:: –
instead of drawing arrows as in Dr Racket.  Information is displayed
using the function(s) in the hook variable *note
racket-show-functions::; it is also available when hovering the mouse
cursor.

   Note: If you find these point-motion features too distracting and/or
slow, in your ‘racket-xp-mode-hook’ you may disable them:

       (require 'racket-xp)
       (add-hook 'racket-xp-mode-hook
                 (lambda ()
                   (remove-hook 'pre-redisplay-functions
                                #'racket-xp-pre-redisplay
                                t)))

   The remaining features discussed below will still work.

   You may also use commands to navigate among a definition and its
uses, or to rename a local definitions and all its uses:

   • *note racket-xp-next-definition::
   • *note racket-xp-previous-definition::
   • *note racket-xp-next-use::
   • *note racket-xp-previous-use::

   In the following little example, not only does drracket/check-syntax
distinguish the various “x” bindings, it understands the two different
imports of “define”:

       #lang racket/base
       (define x 1)
       x
       (let ([x x])
         (+ x 1))
       (module m typed/racket/base
         (define x 2)
         x)

   When point is on the opening parenthesis of an expression in tail
position, it is highlighted using the face *note
racket-xp-tail-position-face::.

   When point is on the opening parenthesis of an enclosing expression
with respect to which one or more expressions are in tail position, it
is highlighted using the face *note racket-xp-tail-target-face::.

   Furthermore, when point is on the opening parenthesis of either kind
of expression, all of the immediately related expressions are also
highlighted.  Various commands move among them:

   • *note racket-xp-tail-up::
   • *note racket-xp-tail-down::
   • *note racket-xp-tail-next-sibling::
   • *note racket-xp-tail-previous-sibling::

   The function ‘racket-xp-complete-at-point’ is added to the variable
‘completion-at-point-functions’.  Note that in this case, it is not
smart about submodules; identifiers are assumed to be definitions from
the file’s module or its imports.  In addition to supplying completion
candidates, it supports the “:company-location” property to inspect the
definition of a candidate and the “:company-doc-buffer” property to view
its documentation.

   When you edit the buffer, existing annotations are retained; their
positions are updated to reflect the edit.  Annotations for new or
deleted text are not requested until after *note
racket-xp-after-change-refresh-delay:: seconds.  The request is made
asynchronously so that Emacs will not block – for moderately complex
source files, it can take some seconds simply to fully expand them, as
well as a little more time for the drracket/check-syntax analysis.  When
the results are ready, all annotations for the buffer are completely
refreshed.

   You may also set *note racket-xp-after-change-refresh-delay:: to nil
and use the ‘racket-xp-annotate’ command manually.

   The mode line changes to reflect the current status of annotations,
and whether or not you had a syntax error.

   If you have one or more syntax errors, ‘next-error’ and
‘previous-error’ navigate among them.  Although most languages will stop
after the first syntax error, some like Typed Racket will try to collect
and report multiple errors.

   You may use ‘xref-find-definitions’ ‘M-.’ , ‘xref-pop-marker-stack’
‘M-x’ ‘xref-pop-marker-stack’, and ‘xref-find-references’: *note
racket-xp-mode:: adds a backend to the variable
‘xref-backend-functions’.  This backend uses information from the
drracket/check-syntax static analysis.  Its ability to find references
is limited to the current file; when it finds none it will try the
default xref backend implementation which is grep-based.

   Tip: This mode follows the convention that a minor mode may only use
a prefix key consisting of “C-c” followed by a punctuation key.  As a
result, ‘racket-xp-control-c-hash-keymap’ is bound to “C-c #” by
default.  Although you might find this awkward to type, remember that as
an Emacs user, you are free to bind this map to a more convenient
prefix, and/or bind any individual commands directly to whatever keys
you prefer.

Key                                                                                                      Binding
‘C-c # j’                                                                                                *note racket-xp-next-definition::
‘C-c # k’                                                                                                *note racket-xp-previous-definition::
‘C-c # n’                                                                                                *note racket-xp-next-use::
‘C-c # p’                                                                                                *note racket-xp-previous-use::
‘C-c # ?’                                                                                                ‘xref-find-references’
‘C-c # r’                                                                                                ‘racket-xp-rename’
‘C-c # ^’                                                                                                *note racket-xp-tail-up::
‘C-c # v’                                                                                                *note racket-xp-tail-down::
‘C-c # >’                                                                                                *note racket-xp-tail-next-sibling::
‘C-c # <’                                                                                                *note racket-xp-tail-previous-sibling::
‘C-c # g’                                                                                                ‘racket-xp-annotate’
‘C-c # N’                                                                                                ‘next-error’
‘C-c # P’                                                                                                ‘previous-error’
‘C-c C-.’                                                                                                *note racket-xp-describe::
‘C-c C-d’                                                                                                *note racket-xp-documentation::
‘C-c C-s’                                                                                                *note racket-describe-search::
‘M-.’ or ‘C-c # .’                                                                                       ‘xref-find-definitions’

   This is a minor mode.  If called interactively, toggle the ‘Racket-Xp
mode’ mode.  If the prefix argument is positive, enable the mode, and if
it is zero or negative, disable the mode.

   If called from Lisp, toggle the mode if ARG is ‘toggle’.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

   To check whether the minor mode is enabled in the current buffer,
evaluate the variable *note racket-xp-mode::.

   The mode’s hook is called both when the mode is enabled and when it
is disabled.


File: racket-mode.info,  Node: racket-xp-describe,  Next: racket-xp-documentation,  Prev: racket-xp-mode,  Up: Explore

6.3.2 racket-xp-describe
------------------------

‘C-c C-.’

   Describe the identifier at point.

   The command varies based on how many ‘C-u’ command prefixes you
supply.

   • ‘C-c C-.’

     Uses the symbol at point.  If no such symbol exists, you are
     prompted enter the identifier, but in this case it only considers
     definitions or imports at the file’s module level – not local
     bindings nor definitions in submodules.

        • If the identifier has installed Racket documentation, then a
          simplified version of the HTML is presented in the buffer,
          including the “blue box”, documentation prose, and examples.

        • Otherwise, if the identifier is a function, then its signature
          is displayed, for example “(name arg-1-name arg-2-name)”.

   • ‘C-u’ ‘C-c C-.’

     Always prompts you to enter a symbol, defaulting to the symbol at
     point if any.

   • ‘C-u’ ‘C-u’ ‘C-c C-.’

     This is an alias for *note racket-describe-search::, which uses
     installed documentation in a *note racket-describe-mode:: buffer
     instead of an external web browser.

   The intent is to give a quick reminder or introduction to something,
regardless of whether it has installed documentation – and to do so
within Emacs, without switching to a web browser.

   This buffer is also displayed when you use ‘company-mode’ and press
F1 or C-h in its pop up completion list.


File: racket-mode.info,  Node: racket-xp-documentation,  Next: racket-xp-next-definition,  Prev: racket-xp-describe,  Up: Explore

6.3.3 racket-xp-documentation
-----------------------------

‘C-c C-d’

   View documentation in an external web browser.

   The command varies based on how many ‘C-u’ command prefixes you
supply.

   • ‘C-c C-d’

     Uses the symbol at point.  Tries to find documentation for an
     identifer defined in the expansion of the current buffer.

     If no such identifer exists, opens the Search Manuals page.  In
     this case, the variable *note
     racket-documentation-search-location:: determines whether the
     search is done locally as with ‘raco doc’, or visits a URL.

   • ‘C-u’ ‘C-c C-d’

     Always prompts you to enter a symbol, defaulting to the symbol at
     point if any.

   • ‘C-u’ ‘C-u’ ‘C-c C-d’

     Always prompts you to enter anything, defaulting to the symbol at
     point if any.

     Proceeds directly to the Search Manuals page.  Use this if you
     would like to see documentation for all identifiers named “define”,
     for example.


File: racket-mode.info,  Node: racket-xp-next-definition,  Next: racket-xp-previous-definition,  Prev: racket-xp-documentation,  Up: Explore

6.3.4 racket-xp-next-definition
-------------------------------

‘C-c # j’

   Move point to the next definition.


File: racket-mode.info,  Node: racket-xp-previous-definition,  Next: racket-xp-next-use,  Prev: racket-xp-next-definition,  Up: Explore

6.3.5 racket-xp-previous-definition
-----------------------------------

‘C-c # k’

   Move point to the previous definition.


File: racket-mode.info,  Node: racket-xp-next-use,  Next: racket-xp-previous-use,  Prev: racket-xp-previous-definition,  Up: Explore

6.3.6 racket-xp-next-use
------------------------

‘C-c # n’

   When point is on a use, go to the next, sibling use.


File: racket-mode.info,  Node: racket-xp-previous-use,  Next: racket-xp-next-error,  Prev: racket-xp-next-use,  Up: Explore

6.3.7 racket-xp-previous-use
----------------------------

‘C-c # p’

   When point is on a use, go to the previous, sibling use.


File: racket-mode.info,  Node: racket-xp-next-error,  Next: racket-xp-previous-error,  Prev: racket-xp-previous-use,  Up: Explore

6.3.8 racket-xp-next-error
--------------------------

‘M-x’ ‘racket-xp-next-error’

   An obsolete alias for ‘next-error’.


File: racket-mode.info,  Node: racket-xp-previous-error,  Next: racket-xp-tail-up,  Prev: racket-xp-next-error,  Up: Explore

6.3.9 racket-xp-previous-error
------------------------------

‘M-x’ ‘racket-xp-previous-error’

   An obsolete alias for ‘previous-error’.


File: racket-mode.info,  Node: racket-xp-tail-up,  Next: racket-xp-tail-down,  Prev: racket-xp-previous-error,  Up: Explore

6.3.10 racket-xp-tail-up
------------------------

‘C-c # ^’

   Go “up” to the expression enclosing an expression in tail position.

   When point is on the opening parenthesis of an expression in tail
position, go its “target” – that is, go to the enclosing expression with
the same continuation as the tail expression.


File: racket-mode.info,  Node: racket-xp-tail-down,  Next: racket-xp-tail-next-sibling,  Prev: racket-xp-tail-up,  Up: Explore

6.3.11 racket-xp-tail-down
--------------------------

‘C-c # v’

   Go “down” to the first tail position enclosed by the current
expression.


File: racket-mode.info,  Node: racket-xp-tail-next-sibling,  Next: racket-xp-tail-previous-sibling,  Prev: racket-xp-tail-down,  Up: Explore

6.3.12 racket-xp-tail-next-sibling
----------------------------------

‘C-c # >’

   Go to the next tail position sharing the same enclosing expression.


File: racket-mode.info,  Node: racket-xp-tail-previous-sibling,  Next: racket-documentation-search,  Prev: racket-xp-tail-next-sibling,  Up: Explore

6.3.13 racket-xp-tail-previous-sibling
--------------------------------------

‘C-c # <’

   Go to the previous tail position sharing the same enclosing
expression.


File: racket-mode.info,  Node: racket-documentation-search,  Next: racket-describe-mode,  Prev: racket-xp-tail-previous-sibling,  Up: Explore

6.3.14 racket-documentation-search
----------------------------------

‘C-c C-d’

   Search documentation.

   This command is useful in several situations:

   • You are not using *note racket-xp-mode:: for a *note racket-mode::
     edit buffer, so *note racket-xp-documentation:: is not available.

   • There is no *note racket-repl-mode:: buffer with a live namespace,
     so *note racket-repl-documentation:: is not available or helpful.

   • You want to search for definitions provided by all modules – for
     example, the “define” syntax provided by racket/base, by
     typed/racket/base, and by other modules, as well definitions or
     topics that merely include “define”.

   This command does not try to go directly to the help topic for a
definition provided by any specific module.  Instead it goes to the
Racket “Search Manuals” page.


File: racket-mode.info,  Node: racket-describe-mode,  Next: racket-describe-search,  Prev: racket-documentation-search,  Up: Explore

6.3.15 racket-describe-mode
---------------------------

‘M-x’ ‘racket-describe-mode’

   Major mode for viewing Racket documentation.

   Many of the default key bindings are similar to ‘Info-mode’, as
listed below.

   To see “On this page” links, use ‘M-g i’ for ‘imenu’, or, when
‘context-menu-mode’ is enabled, right click the mouse.

   Supports bookmarks: ‘bookmark-set’.

   Supports org links: ‘org-store-link’, ‘org-insert-link’, and
‘org-open-at-point’.

   Internal, intra-doc links – which go to other doc pages in the same
*note racket-describe-mode:: buffer in Emacs – are given *note
racket-doc-link-face:: unless the documentation specifies some
non-default face.

   External links – which are opened using the variable *note
racket-browse-url-function::, by default in an external web browser
program – are given *note racket-ext-link-face::.

Key                                                                                                                                               Binding
‘q’                                                                                                                                               ‘quit-window’
‘SPC’                                                                                                                                             ‘scroll-up-command’
‘DEL’ or ‘S-SPC’                                                                                                                                  ‘scroll-down-command’
‘>’                                                                                                                                               ‘end-of-buffer’
‘<’                                                                                                                                               ‘beginning-of-buffer’
‘g’                                                                                                                                               ‘revert-buffer’
‘l’ or ‘b’ or ‘C-c C-b’                                                                                                                           ‘racket-describe-back’
‘r’ or ‘f’ or ‘C-c C-f’                                                                                                                           ‘racket-describe-forward’
‘i’ or ‘C-c C-s’                                                                                                                                  *note racket-describe-search::
‘n’                                                                                                                                               ‘racket-describe-nav-next’
‘p’                                                                                                                                               ‘racket-describe-nav-prev’
‘^’                                                                                                                                               ‘racket-describe-nav-up’
‘C-^’                                                                                                                                             ‘racket-describe-nav-top’
‘x’                                                                                                                                               ‘racket-describe-browse-external’

   In addition to any hooks its parent mode ‘special-mode’ might have
run, this mode runs the hook ‘racket-describe-mode-hook’, as the final
or penultimate step during initialization.


File: racket-mode.info,  Node: racket-describe-search,  Prev: racket-describe-mode,  Up: Explore

6.3.16 racket-describe-search
-----------------------------

‘C-c C-.’ or ‘C-c C-s’

   Search installed documentation; view using *note
racket-describe-mode::.


File: racket-mode.info,  Node: Run,  Next: Test,  Prev: Explore,  Up: Commands

6.4 Run
=======

* Menu:

* racket-repl-mode::
* racket-run::
* racket-run-and-switch-to-repl::
* racket-run-module-at-point::
* racket-repl::
* racket-repl-describe::
* racket-repl-documentation::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-repl-clear::
* racket-repl-clear-leaving-last-prompt::


File: racket-mode.info,  Node: racket-repl-mode,  Next: racket-run,  Up: Run

6.4.1 racket-repl-mode
----------------------

‘M-x’ ‘racket-repl-mode’

   Major mode for Racket REPL.

   You may use ‘xref-find-definitions’ ‘M-.’ and ‘xref-pop-marker-stack’
‘M-x’ ‘xref-pop-marker-stack’: *note racket-repl-mode:: adds a backend
to the variable ‘xref-backend-functions’.  This backend uses information
about identifier bindings and modules from the REPL’s namespace.

Key                                                                                                                                     Binding
‘RET’                                                                                                                                   ‘racket-repl-submit’
‘C-j’                                                                                                                                   ‘newline-and-indent’
‘TAB’                                                                                                                                   ‘indent-for-tab-command’
‘C-M-u’                                                                                                                                 *note racket-backward-up-list::
‘C-M-q’                                                                                                                                 ‘prog-indent-sexp’
‘M-p’                                                                                                                                   ‘racket-repl-previous-input’
‘M-n’                                                                                                                                   ‘racket-repl-next-input’
‘C-M-y’                                                                                                                                 *note racket-insert-lambda::
‘C-c C-u’                                                                                                                               ‘racket-repl-clear-input’
‘C-c C-p’                                                                                                                               ‘racket-repl-previous-prompt-or-run’
‘C-c C-n’                                                                                                                               ‘racket-repl-next-prompt-or-run’
‘C-c C-o’                                                                                                                               ‘racket-repl-delete-output’
‘C-c C-e f’                                                                                                                             *note racket-expand-file::
‘C-c C-e x’                                                                                                                             *note racket-expand-definition::
‘C-c C-e e’                                                                                                                             *note racket-expand-last-sexp::
‘C-c C-e r’                                                                                                                             *note racket-expand-region::
‘C-c C-d’                                                                                                                               *note racket-repl-documentation::
‘C-c C-.’                                                                                                                               *note racket-repl-describe::
‘C-c C-s’                                                                                                                               *note racket-describe-search::
‘C-c C-z’                                                                                                                               ‘racket-repl-switch-to-edit’
‘C-c C-l’                                                                                                                               *note racket-logger::
‘C-c C-c’                                                                                                                               ‘racket-repl-break’
‘C-c C-\’                                                                                                                               ‘racket-repl-exit’
‘)’ or ‘]’ or ‘}’                                                                                                                       *note racket-insert-closing::

   This mode runs the hook ‘racket-repl-mode-hook’, as the final or
penultimate step during initialization.


File: racket-mode.info,  Node: racket-run,  Next: racket-run-and-switch-to-repl,  Prev: racket-repl-mode,  Up: Run

6.4.2 racket-run
----------------

‘M-x’ ‘racket-run’

   Save the buffer in REPL and run your program.

   As well as evaluating the outermost, file module, automatically runs
the submodules specified by the customization variable *note
racket-submodules-to-run::.

   See also *note racket-run-module-at-point::, which runs just the
specific module at point.

   The command varies based on how many ‘C-u’ prefix arguments you
supply.

   • ‘<f5>’

     Follows the *note racket-error-context:: setting.

   • ‘C-u’ ‘<f5>’

     Uses errortrace for improved stack traces, as if *note
     racket-error-context:: were set to “high”.

     This lets you keep *note racket-error-context:: set to a faster
     value like “low” or “medium”, then conveniently re-run when you
     need a better strack trace.

   • ‘C-u’ ‘C-u’ ‘<f5>’

     Instruments code for step debugging.  See *note racket-debug-mode::
     and the variable *note racket-debuggable-files::.

   Each run occurs within a Racket custodian.  Any prior run’s custodian
is shut down, releasing resources like threads and ports.  Each run’s
evaluation environment is reset to the contents of the source file.  In
other words, like Dr Racket, this provides the benefit that your source
file is the “single source of truth”.  At the same time, the run gives
you a REPL inside the namespace of the module, giving you the ability to
explore it interactively.  Any explorations are temporary, unless you
also make them to your source file, they will be lost on the next run.

   See also *note racket-run-and-switch-to-repl::, which is even more
like Dr Racket’s Run command because it selects the REPL window after
running.

   To visit error locations, move point there and press RET or mouse
click.  Or, use the standard ‘next-error’ and ‘previous-error’ commands
from either the edit or REPL buffer.


File: racket-mode.info,  Node: racket-run-and-switch-to-repl,  Next: racket-run-module-at-point,  Prev: racket-run,  Up: Run

6.4.3 racket-run-and-switch-to-repl
-----------------------------------

‘<f5>’

   This is *note racket-run:: followed by selecting the REPL buffer
window.

   This is similar to how Dr Racket behaves.

   To make it even more similar, you may add *note racket-repl-clear::
to the variable *note racket-before-run-hook::.


File: racket-mode.info,  Node: racket-run-module-at-point,  Next: racket-repl,  Prev: racket-run-and-switch-to-repl,  Up: Run

6.4.4 racket-run-module-at-point
--------------------------------

‘C-c C-k’ or ‘C-c C-c’

   Save the buffer and run the module at point.

   Like *note racket-run:: but runs the innermost module around point,
which is determined textually by looking for “module”, “module*”, or
“module+” forms nested to any depth, else simply the outermost, file
module.


File: racket-mode.info,  Node: racket-repl,  Next: racket-repl-describe,  Prev: racket-run-module-at-point,  Up: Run

6.4.5 racket-repl
-----------------

‘M-x’ ‘racket-repl’

   Show a Racket REPL buffer in some window.

   The intended use of Racket Mode’s REPL is that you ‘find-file’ some
specific file, then run it using a command like *note racket-run:: or
*note racket-run-module-at-point::.  The resulting REPL will correspond
to those definitions and match your expectations.

   Therefore this *note racket-repl:: command – which is intended as a
convenience for people who want to “just get a quick scratch REPL” – is
actually implemented as running the file named in the customization
variable *note racket-repl-command-file::.  When that file doesn’t
exist, it is created to contain just “#lang racket/base”.  You may edit
the file to use a different lang, require other modules, or whatever.


File: racket-mode.info,  Node: racket-repl-describe,  Next: racket-repl-documentation,  Prev: racket-repl,  Up: Run

6.4.6 racket-repl-describe
--------------------------

‘C-c C-.’

   Describe the identifier at point.

   The command varies based on how many ‘C-u’ prefix arguments you
supply.

   • ‘C-c C-.’

     Uses the symbol at point.  If no such symbol exists, you are
     prompted enter the identifier, but in this case it only considers
     definitions or imports at the file’s module level – not local
     bindings nor definitions in submodules.

        • If the identifier has installed Racket documentation, then a
          simplified version of the HTML is presented in the buffer,
          including the “blue box”, documentation prose, and examples.

        • Otherwise, if the identifier is a function, then its signature
          is displayed, for example “(name arg-1-name arg-2-name)”.

   • ‘C-u’ ‘C-c C-.’

     Always prompts you to enter a symbol, defaulting to the symbol at
     point if any.

   • ‘C-u’ ‘C-u’ ‘C-c C-.’

     This is an alias for *note racket-describe-search::, which uses
     installed documentation in a *note racket-describe-mode:: buffer
     instead of an external web browser.

   The intent is to give a quick reminder or introduction to something,
regardless of whether it has installed documentation – and to do so
within Emacs, without switching to a web browser.


File: racket-mode.info,  Node: racket-repl-documentation,  Next: racket-racket,  Prev: racket-repl-describe,  Up: Run

6.4.7 racket-repl-documentation
-------------------------------

‘C-c C-d’

   View documentation in an external web browser.

   The command varies based on how many ‘C-u’ command prefixes you
supply.

   • ‘C-c C-d’

     Uses the symbol at point.  Tries to find documentation for an
     identifer defined in the current namespace.

     If no such identifer exists, opens the Search Manuals page.  In
     this case, the variable *note
     racket-documentation-search-location:: determines whether the
     search is done locally as with ‘raco doc’, or visits a URL.

   • ‘C-u’ ‘C-c C-d’

     Prompts you to enter a symbol, defaulting to the symbol at point if
     any.

   • ‘C-u’ ‘C-u’ ‘C-c C-d’

     Prompts you to enter anything, defaulting to the symbol at point if
     any.

     Proceeds directly to the Search Manuals page.  Use this if you
     would like to see documentation for all identifiers named “define”,
     for example.


File: racket-mode.info,  Node: racket-racket,  Next: racket-profile,  Prev: racket-repl-documentation,  Up: Run

6.4.8 racket-racket
-------------------

‘C-M-<f5>’

   Use command-line racket to run the file.

   Uses a shell or terminal buffer as specified by the configuration
variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: racket-profile,  Next: racket-profile-mode,  Prev: racket-racket,  Up: Run

6.4.9 racket-profile
--------------------

‘C-c C-o’

   Like *note racket-run-module-at-point:: but with profiling.

   Results are presented in a *note racket-profile-mode:: buffer, which
also lets you quickly view the source code.

   You may evaluate expressions in the REPL.  They are also profiled.
Use ‘racket-profile-refresh’ to see the updated results.  In other words
a possible workflow is: *note racket-profile:: a .rkt file, call one its
functions in the REPL, and refresh the profile results.

   Caveat: Only source files are instrumented.  You may need to delete
compiled/*.zo files.


File: racket-mode.info,  Node: racket-profile-mode,  Next: racket-logger,  Prev: racket-profile,  Up: Run

6.4.10 racket-profile-mode
--------------------------

‘M-x’ ‘racket-profile-mode’

   Major mode for results of *note racket-profile::.

Key                                                                                          Binding
‘q’                                                                                          ‘quit-window’
‘g’                                                                                          ‘racket-profile-refresh’
‘z’                                                                                          ‘racket-profile-show-zero’
‘f’                                                                                          ‘racket-profile-show-non-project’
‘.’ or ‘RET’                                                                                 ‘racket-profile-visit’

   In addition to any hooks its parent mode ‘tabulated-list-mode’ might
have run, this mode runs the hook ‘racket-profile-mode-hook’, as the
final or penultimate step during initialization.


File: racket-mode.info,  Node: racket-logger,  Next: racket-logger-mode,  Prev: racket-profile-mode,  Up: Run

6.4.11 racket-logger
--------------------

‘C-c C-l’

   Create the *note racket-logger-mode:: buffer.


File: racket-mode.info,  Node: racket-logger-mode,  Next: racket-repl-clear,  Prev: racket-logger,  Up: Run

6.4.12 racket-logger-mode
-------------------------

‘M-x’ ‘racket-logger-mode’

   Major mode for Racket logger output.

   The customization variable *note racket-logger-config:: determines
the levels for topics.  During a session you may change topic levels
using ‘racket-logger-topic-level’.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

Key                                         Binding
‘l’                                         ‘racket-logger-topic-level’
‘w’                                         ‘toggle-truncate-lines’
‘n’                                         ‘racket-logger-next-item’
‘p’                                         ‘racket-logger-previous-item’
‘g’                                         ‘racket-logger-clear’

   In addition to any hooks its parent mode ‘special-mode’ might have
run, this mode runs the hook ‘racket-logger-mode-hook’, as the final or
penultimate step during initialization.


File: racket-mode.info,  Node: racket-repl-clear,  Next: racket-repl-clear-leaving-last-prompt,  Prev: racket-logger-mode,  Up: Run

6.4.13 racket-repl-clear
------------------------

Delete all text in the REPL.

   A suitable value for the hook *note racket-before-run-hook:: if you
want the REPL buffer to be cleared before each run, much like with Dr
Racket.  To do so you can use ‘customize’, or, add to your Emacs init
file something like:

   (add-hook ’racket-before-run-hook #’racket-repl-clear)

   See also the command *note racket-repl-clear-leaving-last-prompt::.


File: racket-mode.info,  Node: racket-repl-clear-leaving-last-prompt,  Prev: racket-repl-clear,  Up: Run

6.4.14 racket-repl-clear-leaving-last-prompt
--------------------------------------------

‘M-x’ ‘racket-repl-clear-leaving-last-prompt’

   Delete all text in the REPL, except for the last prompt.


File: racket-mode.info,  Node: Test,  Next: Eval,  Prev: Run,  Up: Commands

6.5 Test
========

* Menu:

* racket-test::
* racket-raco-test::


File: racket-mode.info,  Node: racket-test,  Next: racket-raco-test,  Up: Test

6.5.1 racket-test
-----------------

‘C-<f5>’ or ‘C-c C-t’

   Run the “test” submodule.

   Put your tests in a “test” submodule.  For example:

         (module+ test
           (require rackunit)
           (check-true #t))

   Any rackunit test failure messages show the location.  You may use
‘next-error’ to jump to the location of each failing test.

   With ‘C-u’ uses errortrace for improved stack traces.  Otherwise
follows the *note racket-error-context:: setting.

   With ‘C-u’ ‘C-u’ also runs the tests with coverage instrumentation.
Expressions not covered by tests are treated as errors – see
‘next-error’.

   See also:
   • *note racket-fold-all-tests::
   • *note racket-unfold-all-tests::


File: racket-mode.info,  Node: racket-raco-test,  Prev: racket-test,  Up: Test

6.5.2 racket-raco-test
----------------------

‘M-x’ ‘racket-raco-test’

   Use command-line raco test to run the “test” submodule.

   Uses a shell or terminal buffer as specified by the configuration
variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: Eval,  Next: Collections,  Prev: Test,  Up: Commands

6.6 Eval
========

* Menu:

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::


File: racket-mode.info,  Node: racket-send-region,  Next: racket-send-definition,  Up: Eval

6.6.1 racket-send-region
------------------------

‘C-c C-r’

   Send the current region (if any) to the Racket REPL.

   See the customization variable *note
racket-repl-echo-sent-expressions::.


File: racket-mode.info,  Node: racket-send-definition,  Next: racket-send-last-sexp,  Prev: racket-send-region,  Up: Eval

6.6.2 racket-send-definition
----------------------------

‘C-M-x’

   Send the current definition to the Racket REPL.

   See the customization variable *note
racket-repl-echo-sent-expressions::.


File: racket-mode.info,  Node: racket-send-last-sexp,  Prev: racket-send-definition,  Up: Eval

6.6.3 racket-send-last-sexp
---------------------------

‘C-x C-e’

   Send the expression before point to the Racket REPL.

   The expression may be either an at-expression or an s-expression.

   When the expression is a sexp comment, the sexp itself is sent,
without the #; prefix.

   See the customization variable *note
racket-repl-echo-sent-expressions::.


File: racket-mode.info,  Node: Collections,  Next: Macro expand,  Prev: Eval,  Up: Commands

6.7 Collections
===============

* Menu:

* racket-open-require-path::


File: racket-mode.info,  Node: racket-open-require-path,  Up: Collections

6.7.1 racket-open-require-path
------------------------------

‘C-c C-x C-f’

   Like Dr Racket’s Open Require Path.

   Type (or delete) characters that are part of a module path name.
“Fuzzy” matches appear.  For example try typing “t/t/r”.

   Choices are displayed in a vertical list.  The current choice is at
the top, marked with “->”.

   • C-n and C-p move among the choices.
   • RET on a directory adds its contents to the choices.
   • RET on a file exits doing ‘find-file’.
   • C-g aborts.


File: racket-mode.info,  Node: Macro expand,  Next: Packages,  Prev: Collections,  Up: Commands

6.8 Macro expand
================

* Menu:

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::


File: racket-mode.info,  Node: racket-stepper-mode,  Next: racket-expand-file,  Up: Macro expand

6.8.1 racket-stepper-mode
-------------------------

‘M-x’ ‘racket-stepper-mode’

   Major mode for Racket stepper output.

   Used by the commands *note racket-expand-file::, *note
racket-expand-definition::, *note racket-expand-region::, and *note
racket-expand-last-sexp::.

Key                                                                                      Binding
‘RET’                                                                                    ‘racket-stepper-step’
‘n’ or ‘j’                                                                               ‘racket-stepper-next-item’
‘p’ or ‘k’                                                                               ‘racket-stepper-previous-item’
‘g’                                                                                      ‘racket-stepper-refresh’

   In addition to any hooks its parent mode ‘special-mode’ might have
run, this mode runs the hook ‘racket-stepper-mode-hook’, as the final or
penultimate step during initialization.


File: racket-mode.info,  Node: racket-expand-file,  Next: racket-expand-region,  Prev: racket-stepper-mode,  Up: Macro expand

6.8.2 racket-expand-file
------------------------

‘C-c C-e f’

   Expand the *note racket-mode:: buffer’s file in *note
racket-stepper-mode::.

   Uses the ‘macro-debugger’ package to do the expansion.

   You do not need to *note racket-run:: the file first; the namespace
active in the REPL is not used.

   If the file is non-trivial and/or is not compiled to a .zo bytecode
file, then it might take many seconds before the original form is
displayed and you can start stepping.

   With ‘C-u’ behaves as if *note racket-expand-hiding:: were ’disabled.


File: racket-mode.info,  Node: racket-expand-region,  Next: racket-expand-definition,  Prev: racket-expand-file,  Up: Macro expand

6.8.3 racket-expand-region
--------------------------

‘C-c C-e r’

   Expand the active region using *note racket-stepper-mode::.

   Uses the ‘macro-debugger’ package to do the expansion.

   With ‘C-u’ behaves as if *note racket-expand-hiding:: were ’disabled.


File: racket-mode.info,  Node: racket-expand-definition,  Next: racket-expand-last-sexp,  Prev: racket-expand-region,  Up: Macro expand

6.8.4 racket-expand-definition
------------------------------

‘C-c C-e x’

   Expand the definition around point using *note racket-stepper-mode::.

   Uses the ‘macro-debugger’ package to do the expansion.

   With ‘C-u’ behaves as if *note racket-expand-hiding:: were ’disabled.


File: racket-mode.info,  Node: racket-expand-last-sexp,  Prev: racket-expand-definition,  Up: Macro expand

6.8.5 racket-expand-last-sexp
-----------------------------

‘C-c C-e e’

   Expand the sexp before point using *note racket-stepper-mode::.

   Uses the ‘macro-debugger’ package to do the expansion.

   With ‘C-u’ behaves as if *note racket-expand-hiding:: were ’disabled.


File: racket-mode.info,  Node: Packages,  Next: Debug,  Prev: Macro expand,  Up: Commands

6.9 Packages
============

* Menu:

* racket-package-refresh::
* list-racket-packages::
* racket-package-mode::
* describe-racket-package::


File: racket-mode.info,  Node: racket-package-refresh,  Next: list-racket-packages,  Up: Packages

6.9.1 racket-package-refresh
----------------------------

‘M-x’ ‘racket-package-refresh’

   Refresh the local copy of package catalogs.

   Will make HTTP requests to remote catalog servers.  May take a few
seconds to complete.


File: racket-mode.info,  Node: list-racket-packages,  Next: racket-package-mode,  Prev: racket-package-refresh,  Up: Packages

6.9.2 list-racket-packages
--------------------------

‘M-x’ ‘list-racket-packages’

   Open a *note racket-package-mode:: buffer for the active back end.


File: racket-mode.info,  Node: racket-package-mode,  Next: describe-racket-package,  Prev: list-racket-packages,  Up: Packages

6.9.3 racket-package-mode
-------------------------

‘M-x’ ‘racket-package-mode’

   Major mode for Racket package management.

   The list of packages is equivalent to “raco pkg show -all” on the
active back end – that is, all packages installed manually or as
dependencies – plus packages available from your configured catalogs,
assuming you have run the command *note racket-package-refresh::.

   On each row you can press RET to ‘describe-racket-package’, which
opens a buffer where you can view details, and use buttons to
install/update/remove the package.

Key                                             Binding
‘RET’                                           ‘racket-package-describe’

   In addition to any hooks its parent mode ‘tabulated-list-mode’ might
have run, this mode runs the hook ‘racket-package-mode-hook’, as the
final or penultimate step during initialization.


File: racket-mode.info,  Node: describe-racket-package,  Prev: racket-package-mode,  Up: Packages

6.9.4 describe-racket-package
-----------------------------

‘M-x’ ‘describe-racket-package’

   Describe details of a Racket package.

   Depending on the package status, buttons let you install, update,
and/or remove the package and its dependencies.  These convenience
buttons are equivalent to using the command line on the active back end
to do “raco pkg {install update remove} –auto”.  For other operations,
you still need to use “raco pkg” yourself; see
<https://docs.racket-lang.org/pkg/cmdline.html>.

   Detail values are links when possible:

   • The _Catalog_ (when “<https://pkgs.racket-lang.org>”) links to the
     package’s web page, which may have additional details not available
     locally.

   • The _Source_ links to the repo’s web page or local filesystem.

   • The _Directory_ for an installed package opens a dired buffer.

   • Each _Dependencies_ name links to details about that package.

   • For installed packages, each _Modules_ item links to the local
     file.  There is also a button to each module’s locally installed
     documentation, if any.

   If the package is available from a catalog, additional details will
be shown, assuming you have run the command *note
racket-package-refresh::.


File: racket-mode.info,  Node: Debug,  Next: Other,  Prev: Packages,  Up: Commands

6.10 Debug
==========

* Menu:

* racket-debug-mode::
* racket-debug-step::
* racket-debug-step-over::
* racket-debug-step-out::
* racket-debug-forward-breakable::
* racket-debug-backward-breakable::
* racket-debug-run-to-here::
* racket-debug-set-break-expression::
* racket-debug-clear-break-expression::
* racket-debug-toggle-break-expression::
* racket-debug-forward-break-expression::
* racket-debug-backward-break-expression::
* racket-debug-set-local::
* racket-debug-continue::
* racket-debug-go::


File: racket-mode.info,  Node: racket-debug-mode,  Next: racket-debug-step,  Up: Debug

6.10.1 racket-debug-mode
------------------------

‘M-x’ ‘racket-debug-mode’

   Minor mode enabled during step debugging breaks.

   How to step debug:

  1. “Instrument” code for step debugging.

     Use two ‘C-u’ command prefixes – for either *note racket-run:: or
     *note racket-run-module-at-point:: – to instrument and run the file
     with step debugging.

     Imported files are also instrumented if they are in the variable
     *note racket-debuggable-files::.

     Execution will pause at the first breakable position.

  2. Whenever a break occurs:

     In the *note racket-mode:: buffer where the break is located, *note
     racket-debug-mode:: is enabled.  This minor mode makes the buffer
     read-only, provides visual feedback – about the break position,
     local variable values, and result values – and provides shortcut
     keys:

Key                                             Binding
‘SPC’                                           *note racket-debug-step::
‘o’                                             *note racket-debug-step-over::
‘u’                                             *note racket-debug-step-out::
‘n’                                             *note racket-debug-forward-breakable::
‘p’                                             *note racket-debug-backward-breakable::
‘h’                                             *note racket-debug-run-to-here::
‘!’                                             *note racket-debug-toggle-break-expression::
‘N’                                             *note racket-debug-forward-break-expression::
‘P’                                             *note racket-debug-backward-break-expression::
‘=’                                             *note racket-debug-set-local::
‘c’                                             *note racket-debug-continue::
‘g’                                             *note racket-debug-go::
‘?’                                             ‘racket-debug-help’

   Tip: After your program runs to completion and returns to a REPL
prompt, the code remains instrumented.  As a result, in the REPL if you
enter expressions that evaluate instrumented code, you can debug those,
too.

   This is a minor mode.  If called interactively, toggle the
‘Racket-Debug mode’ mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

   If called from Lisp, toggle the mode if ARG is ‘toggle’.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

   To check whether the minor mode is enabled in the current buffer,
evaluate the variable *note racket-debug-mode::.

   The mode’s hook is called both when the mode is enabled and when it
is disabled.


File: racket-mode.info,  Node: racket-debug-step,  Next: racket-debug-step-over,  Prev: racket-debug-mode,  Up: Debug

6.10.2 racket-debug-step
------------------------

‘SPC’

   Step to next breakable position.

   With ‘C-u’ substitute values.


File: racket-mode.info,  Node: racket-debug-step-over,  Next: racket-debug-step-out,  Prev: racket-debug-step,  Up: Debug

6.10.3 racket-debug-step-over
-----------------------------

‘o’

   Step over next expression.

   With ‘C-u’ , substitute values.


File: racket-mode.info,  Node: racket-debug-step-out,  Next: racket-debug-forward-breakable,  Prev: racket-debug-step-over,  Up: Debug

6.10.4 racket-debug-step-out
----------------------------

‘u’

   Step out.

   With ‘C-u’ , substitute values.


File: racket-mode.info,  Node: racket-debug-forward-breakable,  Next: racket-debug-backward-breakable,  Prev: racket-debug-step-out,  Up: Debug

6.10.5 racket-debug-forward-breakable
-------------------------------------

‘n’

   Move to next breakable position in current buffer.

   Useful followed by commands like *note racket-debug-run-to-here:: or
*note racket-debug-set-break-expression::.


File: racket-mode.info,  Node: racket-debug-backward-breakable,  Next: racket-debug-run-to-here,  Prev: racket-debug-forward-breakable,  Up: Debug

6.10.6 racket-debug-backward-breakable
--------------------------------------

‘p’

   Move to previous breakable position in current buffer.

   Useful followed by commands like *note racket-debug-run-to-here:: or
*note racket-debug-set-break-expression::.


File: racket-mode.info,  Node: racket-debug-run-to-here,  Next: racket-debug-set-break-expression,  Prev: racket-debug-backward-breakable,  Up: Debug

6.10.7 racket-debug-run-to-here
-------------------------------

‘h’

   Run to point.

   Equivalent to adding a temporary unconditional break at point,
followed by *note racket-debug-continue::.

   With ‘C-u’ , substitute values.


File: racket-mode.info,  Node: racket-debug-set-break-expression,  Next: racket-debug-clear-break-expression,  Prev: racket-debug-run-to-here,  Up: Debug

6.10.8 racket-debug-set-break-expression
----------------------------------------

‘M-x’ ‘racket-debug-set-break-expression’

   Set a break expression at a breakable position.

   Break expressions encapsulate a range of traditional debugger
features like conditional breakpoints and watchpoints.

   Each break expression consists of a Racket expression, which will be
evaluated in a context where local variables exist.

   Unless the expression evaluates to Racket false or void, execution
will break there.  In other words, this is a “conditional breakpoint”.

   In addition, the expression may invoke ‘#%dump’, which displays
information about all locals (and for after-breaks, the result values)
to both the REPL and the racket-mode-debugger logger topic.  In other
words, this is a “watchpoint”.  Although *note racket-debug-mode::
already shows these values _in situ_ when at a break, this may be useful
if you want a history.

   For example, if the code around the point is something like ‘(for ([n
100]) ___)’, then:

   • ‘#t’ means break always.

   • ‘(zero? (modulo n 10))’ breaks every 10 times through the loop.

   • ‘(when (even? n) (#%dump))’ dumps watch information every other
     time through the loop, but never breaks.

   The expression may consist of any Racket sub-expressions that
evaluate without error in that local context.

   Each break expression is displayed using the customization variables
‘racket-debug-break-expression-string’ and
‘racket-debug-break-expression-face’.

   Note: If you’re warned that point isn’t known to be a breakable
position, that might be because it truly isn’t, or, just because *note
racket-debug-mode:: is inactive therefore the breakable positions aren
uknown.  Worst case, if you set a break expression someplace that is not
breakable, it is ignored.  With a few exceptions – such as close paren
positions that are tail calls – most open parens and close parens are
breakble positions in s-expression languages.  See the commands *note
racket-debug-forward-breakable:: and *note
racket-debug-backward-breakable::.


File: racket-mode.info,  Node: racket-debug-clear-break-expression,  Next: racket-debug-toggle-break-expression,  Prev: racket-debug-set-break-expression,  Up: Debug

6.10.9 racket-debug-clear-break-expression
------------------------------------------

‘M-x’ ‘racket-debug-clear-break-expression’

   When a break expression exists at point, clear it and return true.


File: racket-mode.info,  Node: racket-debug-toggle-break-expression,  Next: racket-debug-forward-break-expression,  Prev: racket-debug-clear-break-expression,  Up: Debug

6.10.10 racket-debug-toggle-break-expression
--------------------------------------------

‘!’

   Set or clear a break expression.

   See *note racket-debug-clear-break-expression:: or *note
racket-debug-set-break-expression::.


File: racket-mode.info,  Node: racket-debug-forward-break-expression,  Next: racket-debug-backward-break-expression,  Prev: racket-debug-toggle-break-expression,  Up: Debug

6.10.11 racket-debug-forward-break-expression
---------------------------------------------

‘N’

   Move to next *note racket-debug-set-break-expression:: location.


File: racket-mode.info,  Node: racket-debug-backward-break-expression,  Next: racket-debug-set-local,  Prev: racket-debug-forward-break-expression,  Up: Debug

6.10.12 racket-debug-backward-break-expression
----------------------------------------------

‘P’

   Move to previous *note racket-debug-set-break-expression:: location.


File: racket-mode.info,  Node: racket-debug-set-local,  Next: racket-debug-continue,  Prev: racket-debug-backward-break-expression,  Up: Debug

6.10.13 racket-debug-set-local
------------------------------

‘=’

   Set local variable to new value.


File: racket-mode.info,  Node: racket-debug-continue,  Next: racket-debug-go,  Prev: racket-debug-set-local,  Up: Debug

6.10.14 racket-debug-continue
-----------------------------

‘c’

   Continue, utilizing break expressions.

   Execution pauses at any position whose break expression evaluates to
a true, non-void value.

   With ‘C-u’ , substitute values.


File: racket-mode.info,  Node: racket-debug-go,  Prev: racket-debug-continue,  Up: Debug

6.10.15 racket-debug-go
-----------------------

‘g’

   Go unconditionally, ignoring all break expressions.

   Similar to continuing the program normally, without stepping or
evaluating any break expressions – although code annotated for debugging
runs more slowly.

   With ‘C-u’ , substitute values.


File: racket-mode.info,  Node: Other,  Prev: Debug,  Up: Commands

6.11 Other
==========

* Menu:

* racket-mode-start-faster::
* racket-mode-start-slower::


File: racket-mode.info,  Node: racket-mode-start-faster,  Next: racket-mode-start-slower,  Up: Other

6.11.1 racket-mode-start-faster
-------------------------------

‘M-x’ ‘racket-mode-start-faster’

   Compile Racket Mode’s .rkt files for faster startup.

   Racket Mode is implemented as an Emacs Lisp “front end” that talks to
a Racket process “back end”.  Because Racket Mode is delivered as an
Emacs package instead of a Racket package, installing it does not do the
‘raco setup’ that is normally done for Racket packages.

   This command will do a ‘raco make’ of Racket Mode’s .rkt files,
creating bytecode files in ‘compiled/’ subdirectories.  As a result,
when a command must start the Racket process, it will start somewhat
faster.

   On many computers, the resulting speed up is negligible, and might
not be worth the complication.

   If you run this command, ever, you will need to run it again after:

   • Installing an updated version of Racket Mode.  Otherwise, you might
     lose some of the speed-up.

   • Installing a new version of Racket and/or changing the value of the
     variable *note racket-program::.  Otherwise, you might get an error
     message due to the bytecode being different versions.

   To revert to compiling on startup, use *note
racket-mode-start-slower::.


File: racket-mode.info,  Node: racket-mode-start-slower,  Prev: racket-mode-start-faster,  Up: Other

6.11.2 racket-mode-start-slower
-------------------------------

‘M-x’ ‘racket-mode-start-slower’

   Delete the “compiled” directories made by *note
racket-mode-start-faster::.


File: racket-mode.info,  Node: Variables,  Next: Configuration functions,  Prev: Commands,  Up: Top

7 Variables
***********

* Menu:

* General variables::
* Hash lang variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::
* Showing information::
* Running racket and raco commands in a shell or terminal::
* Racket input method::


File: racket-mode.info,  Node: General variables,  Next: Hash lang variables,  Up: Variables

7.1 General variables
=====================

* Menu:

* racket-program::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-user-command-line-arguments::
* racket-browse-url-function::
* racket-xp-after-change-refresh-delay::
* racket-xp-highlight-unused-regexp::
* racket-xp-add-binding-faces::
* racket-xp-eldoc-level::
* racket-documentation-search-location::
* racket-expand-hiding::


File: racket-mode.info,  Node: racket-program,  Next: racket-command-timeout,  Up: General variables

7.1.1 racket-program
--------------------

Pathname of the Racket executable or command line to launch it.

   • If the value of this variable is a string, it will be interpreted
     as a simple command without arguments.

   • If it is a list of strings, the first element will be taken to be
     the executable, and the rest of the list command line arguments to
     pass to it before any other arguments.

   Note that a back end configuration can override this with a non-nil
‘racket-program’ property list value.  See *note racket-add-back-end::.


File: racket-mode.info,  Node: racket-command-timeout,  Next: racket-memory-limit,  Prev: racket-program,  Up: General variables

7.1.2 racket-command-timeout
----------------------------

How many seconds to wait for command server responses.

   Note: This is mostly obsolete, fortunately, because it applies only
to commands that must block the Emacs UI until they get a response.
Instead most Racket Mode commands these days receive their response
asychronously.


File: racket-mode.info,  Node: racket-memory-limit,  Next: racket-error-context,  Prev: racket-command-timeout,  Up: General variables

7.1.3 racket-memory-limit
-------------------------

Terminate the Racket process if memory use exceeds this value in MB.

   Changes to this value take effect upon the next *note racket-run::.
A value of 0 means no limit.

   Caveat: This uses Racket’s ‘custodian-limit-memory’, which does not
enforce the limit exactly.  Instead, the program will be terminated upon
the first garbage collection where memory exceeds the limit (maybe by a
significant amount).


File: racket-mode.info,  Node: racket-error-context,  Next: racket-user-command-line-arguments,  Prev: racket-memory-limit,  Up: General variables

7.1.4 racket-error-context
--------------------------

The amount of context for error messages.

   Each increasing level supplies better context (“stack trace”) for
error messages, but causing your program to run more slowly.

   • low corresponds to compile-enforce-module-constants #t and
     compile-context-preservation-enabled #f.

   • medium corresponds to compile-enforce-module-constants #f and
     compile-context-preservation-enabled #t, which disables some
     optimizations like inlining.

   • high corresponds to medium plus the use of errortrace, which
     extensively instruments your code and therefore might cause it to
     run significantly slower.

   Tip: Regardless of this setting, you can enable high errortrace for a
specific *note racket-run:: or *note racket-run-module-at-point:: by
using ‘C-u’ .  This lets you normally run with a lower, faster setting,
and re-run when desired to get a more-helpful error message.


File: racket-mode.info,  Node: racket-user-command-line-arguments,  Next: racket-browse-url-function,  Prev: racket-error-context,  Up: General variables

7.1.5 racket-user-command-line-arguments
----------------------------------------

List of command-line arguments to supply to your Racket program.

   Accessible in your Racket program in the usual way — the parameter
‘current-command-line-arguments’ and friends.

   This is an Emacs buffer-local variable — convenient to set as a file
local variable.  For example at the end of your .rkt file:

         ;; Local Variables:
         ;; racket-user-command-line-arguments: ("-f" "bar")
         ;; End:

   Set this way, the value must be an *unquoted* list of strings.  For
example:

         ("-f" "bar")

   The following values will _not_ work:

         '("-f" "bar")
         (list "-f" "bar")


File: racket-mode.info,  Node: racket-browse-url-function,  Next: racket-xp-after-change-refresh-delay,  Prev: racket-user-command-line-arguments,  Up: General variables

7.1.6 racket-browse-url-function
--------------------------------

Function to call to browse a URL.

   Defaults to *note racket-browse-url-using-temporary-file:: on macOS
and ‘browse-url-browser-function’ on other platforms.


File: racket-mode.info,  Node: racket-xp-after-change-refresh-delay,  Next: racket-xp-highlight-unused-regexp,  Prev: racket-browse-url-function,  Up: General variables

7.1.7 racket-xp-after-change-refresh-delay
------------------------------------------

Seconds to wait before refreshing *note racket-xp-mode:: annotations.

   Set to nil to disable automatic refresh and manually use
‘racket-xp-annotate’.


File: racket-mode.info,  Node: racket-xp-highlight-unused-regexp,  Next: racket-xp-add-binding-faces,  Prev: racket-xp-after-change-refresh-delay,  Up: General variables

7.1.8 racket-xp-highlight-unused-regexp
---------------------------------------

Only give *note racket-xp-unused-face:: to unused bindings that match
this regexp.

   The default is to highlight identifiers that do not start with an
underline, which is a common convention.


File: racket-mode.info,  Node: racket-xp-add-binding-faces,  Next: racket-xp-eldoc-level,  Prev: racket-xp-highlight-unused-regexp,  Up: General variables

7.1.9 racket-xp-add-binding-faces
---------------------------------

Have *note racket-xp-mode:: fontify binding identifier sites.

   A ’font-lock-face property is added for bindings from:

   • the module language, using *note racket-xp-binding-lang-face:: and
     *note racket-xp-binding-lang-use-face::.

   • other imports, using *note racket-xp-binding-import-face:: and
     *note racket-xp-binding-import-use-face::.

   • local definitions, using *note racket-xp-binding-local-face:: and
     *note racket-xp-binding-local-use-face::.

   This has a visible effect only when there is _not_ also a ’face
property applied by the major mode’s fontification.


File: racket-mode.info,  Node: racket-xp-eldoc-level,  Next: racket-documentation-search-location,  Prev: racket-xp-add-binding-faces,  Up: General variables

7.1.10 racket-xp-eldoc-level
----------------------------

How much documentation to show via ‘eldoc’.

   Used by ‘racket-xp-eldoc-point-or-sexp-head’.

   • Minimal: Only the help-echo string.

   • Summary: Also the signature a.k.a.  “bluebox” from the
     documentation.

   • Complete: Also the complete prose documentation.

   A third-party package like ‘eldoc-box’ can be useful for all but the
minimal level.  Even some bluebox signatures can take many lines to show
on screen.


File: racket-mode.info,  Node: racket-documentation-search-location,  Next: racket-expand-hiding,  Prev: racket-xp-eldoc-level,  Up: General variables

7.1.11 racket-documentation-search-location
-------------------------------------------

The location of the Racket “Search Manuals” web page.  Where *note
racket-documentation-search::, *note racket-xp-documentation:: and *note
racket-repl-documentation:: should look for the search page.

   • If the value of this variable is the symbol “local”, open the
     search page from the local documentation, as with “raco doc”.

   • Otherwise, the value is a string recognizable by ‘format’, with
     “%s” at the point at which to insert the user’s search text after
     applying ‘url-hexify-string’.  Apart from “%s”, the string should
     be a properly encoded URL.


File: racket-mode.info,  Node: racket-expand-hiding,  Prev: racket-documentation-search-location,  Up: General variables

7.1.12 racket-expand-hiding
---------------------------

The macro hiding policy for commands like *note racket-expand-file::.


File: racket-mode.info,  Node: Hash lang variables,  Next: REPL variables,  Prev: General variables,  Up: Variables

7.2 Hash lang variables
=======================

* Menu:

* racket-hash-lang-token-face-alist::
* racket-hash-lang-module-language-hook::


File: racket-mode.info,  Node: racket-hash-lang-token-face-alist,  Next: racket-hash-lang-module-language-hook,  Up: Hash lang variables

7.2.1 racket-hash-lang-token-face-alist
---------------------------------------

An association list from color-lexer token symbols to face symbols.

   Note: In many Racket languages, the lexer classifies tokens for
identifiers as ’symbol.  In many programs, a majority of the source
consists of identifiers at binding definition and use sites.  Therefore
the appearance of “symbol” tokens is significant, and a matter of
personal preference.

   • If you prefer a “plainer” appearance, similar to Dr Racket: Add
     ’symbol with the value ’default.  This gives an explicit ’face
     property that prevails over any ’font-lock-face property that a
     minor mode might apply to enhance the basic fontification.

   • If you prefer a more “colorful” appearance, similar to “classic”
     *note racket-mode::: Do _not_ map ’symbol tokens in this list.  See
     *note racket-hash-lang-module-language-hook:: for ideas.

   Note: Some tokens are hardwired and not customizable by this list:
Comment tokens use the face ‘font-lock-comment-face’, sometimes blended
with other faces.  Parenthesis tokens use the face ‘parenthesis’ if
defined, as by the paren-face package.  String tokens use
‘font-lock-string-face’.  Text tokens, e.g.  Scribble text, use the face
*note racket-hash-lang-text::.


File: racket-mode.info,  Node: racket-hash-lang-module-language-hook,  Prev: racket-hash-lang-token-face-alist,  Up: Hash lang variables

7.2.2 racket-hash-lang-module-language-hook
-------------------------------------------

Hook run when the module language changes.

   Typically in Emacs each language gets its own major mode.  As a
result, the major mode hook is your opportunity to express preferences.
However *note racket-hash-lang-mode:: handles radically different kinds
of hash langs in one major mode.  And a given buffer can change langs
when you edit the “#lang” line.  As a result,
‘racket-hash-lang-mode-hook’ is not useful for per-lang configuration.
Instead you need a kind of “sub major mode hook”.  This is that hook.

   The hook is run when a file is first visited, and thereafter whenever
the “#lang” line is edited – provided that results in different language
info; for example changing from “#lang racket” to “#lang racket/base”
will _not_ run the hook.

   The function is called with a string returned by the lang’s
“module-language” info key.  This info key is supplied automatically
when a language is defined using syntax/module-reader:

   <https://docs.racket-lang.org/syntax/reader-helpers.html#%28mod-path._syntax%2Fmodule-reader%29>.

   Otherwise a lang might not supply this and the value will be nil.

   The hook is useful when you want to vary Emacs behavior in ways that
go beyond what a lang can describe.  This may include enabling “fancy”
or “classic” Emacs behaviors only for s-expression langs.

   For example, maybe you want to use ‘paredit-mode’ when it is suitable
for the module language, else ‘electric-pair-local-mode’:

       (defun my-hook (module-language)
         (let ((rackety
                (member module-language
                        (list "racket" "racket/base"
                              "typed/racket" "typed/racket/base"))))
           (electric-pair-local-mode (if rackety -1 1))
           (paredit-mode (if rackety 1 -1))))
       (add-hook 'racket-hash-lang-module-language-hook #'my-hook)

   A similar tactic can be used for ‘smartparens’.  In general, neither
of these modes is likely to work well unless the hash-lang uses racket
for drracket:grouping-position, in which case *note
racket-hash-lang-mode:: uses the classic *note racket-mode::
syntax-table for the buffer.  Otherwise you should not enable one of
these modes, and instead just use the simple delimiter matching of
‘electric-pair-local-mode’, as configured by *note
racket-hash-lang-mode::.

   As another example, if you prefer more colors than just tokens,
choices include:

   • Enable *note racket-xp-mode:: in ‘racket-hash-lang-mode-hook’ and
     in the module language hook locally set *note
     racket-xp-add-binding-faces:::

       (setq-local racket-xp-add-binding-faces t)

   OR

   • Use some of the regexp search-based fontification from classic
     *note racket-mode:: for rackety module languages:

       (require 'racket-font-lock)
       (if rackety
           (font-lock-add-keywords nil
                                   (append racket-font-lock-keywords-2
                                           racket-font-lock-keywords-3))
         (font-lock-remove-keywords nil
                                    (append racket-font-lock-keywords-2
                                            racket-font-lock-keywords-3)))


File: racket-mode.info,  Node: REPL variables,  Next: Other variables,  Prev: Hash lang variables,  Up: Variables

7.3 REPL variables
==================

* Menu:

* racket-repl-buffer-name-function::
* racket-submodules-to-run::
* racket-repl-history-directory::
* racket-history-filter-regexp::
* racket-images-inline::
* racket-imagemagick-props::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-images-do-not-use-svg::
* racket-pretty-print::
* racket-repl-command-file::
* racket-repl-echo-sent-expressions::


File: racket-mode.info,  Node: racket-repl-buffer-name-function,  Next: racket-submodules-to-run,  Up: REPL variables

7.3.1 racket-repl-buffer-name-function
--------------------------------------

How to associate *note racket-mode:: edit buffers with *note
racket-repl-mode:: buffers.

   The default is nil, which is equivalent to supplying *note
racket-repl-buffer-name-shared::: One REPL buffer is shared.

   Other predefined choices include *note
racket-repl-buffer-name-unique:: and *note
racket-repl-buffer-name-project::.

   This is used when a *note racket-mode:: buffer is created.  Changing
this to a new value only affects *note racket-mode:: buffers created
later.

   Any such function takes no arguments, should look at the variable
‘buffer-file-name’ if necessary, and either ‘setq-default’ or
‘setq-local’ the variable ‘racket-repl-buffer-name’ to a desired *note
racket-repl-mode:: buffer name.  As a result, *note racket-run::
commands will use a buffer of that name, creating it if necessary.


File: racket-mode.info,  Node: racket-submodules-to-run,  Next: racket-repl-history-directory,  Prev: racket-repl-buffer-name-function,  Up: REPL variables

7.3.2 racket-submodules-to-run
------------------------------

Extra submodules to run.

   This is a list of submodules.  Each submodule is described as a list,
to support submodules nested to any depth.

   This is used by commands that emulate the DrRacket Run command:

   • *note racket-run::
   • *note racket-run-and-switch-to-repl:: ‘<f5>’

   It is NOT used by commands that run one specific module, such as:

   • *note racket-run-module-at-point:: ‘C-c C-k’ or ‘C-c C-c’
   • *note racket-test:: ‘C-<f5>’ or ‘C-c C-t’
   • *note racket-profile::


File: racket-mode.info,  Node: racket-repl-history-directory,  Next: racket-history-filter-regexp,  Prev: racket-submodules-to-run,  Up: REPL variables

7.3.3 racket-repl-history-directory
-----------------------------------

Directory for *note racket-repl-mode:: history files.


File: racket-mode.info,  Node: racket-history-filter-regexp,  Next: racket-images-inline,  Prev: racket-repl-history-directory,  Up: REPL variables

7.3.4 racket-history-filter-regexp
----------------------------------

Input matching this regexp are NOT saved on the history list.  Default
value is a regexp to ignore input that is all whitespace.


File: racket-mode.info,  Node: racket-images-inline,  Next: racket-imagemagick-props,  Prev: racket-history-filter-regexp,  Up: REPL variables

7.3.5 racket-images-inline
--------------------------

Whether to display inline images in the REPL.


File: racket-mode.info,  Node: racket-imagemagick-props,  Next: racket-images-keep-last,  Prev: racket-images-inline,  Up: REPL variables

7.3.6 racket-imagemagick-props
------------------------------

Use ImageMagick with these properties for REPL images.

   When this property list is not empty – and the variable *note
racket-images-inline:: is true, and Emacs is built with with ImageMagick
support – then ‘create-image’ is called with “imagemagick” as the type
and with this property list.

   For example, to scale images whose width is larger than 500 pixels,
supply (:max-width 500).


File: racket-mode.info,  Node: racket-images-keep-last,  Next: racket-images-system-viewer,  Prev: racket-imagemagick-props,  Up: REPL variables

7.3.7 racket-images-keep-last
-----------------------------

How many images to keep in the image cache.


File: racket-mode.info,  Node: racket-images-system-viewer,  Next: racket-images-do-not-use-svg,  Prev: racket-images-keep-last,  Up: REPL variables

7.3.8 racket-images-system-viewer
---------------------------------

The image viewer program to use for ‘racket-view-image’.


File: racket-mode.info,  Node: racket-images-do-not-use-svg,  Next: racket-pretty-print,  Prev: racket-images-system-viewer,  Up: REPL variables

7.3.9 racket-images-do-not-use-svg
----------------------------------

Do not use SVG to render images?

   Note: This value is used only when starting a back end – _not_ for
each run.  If you change this, for it to take effect you must restart by
using ‘racket-start-back-end’.


File: racket-mode.info,  Node: racket-pretty-print,  Next: racket-repl-command-file,  Prev: racket-images-do-not-use-svg,  Up: REPL variables

7.3.10 racket-pretty-print
--------------------------

Use pretty-print instead of plain print?

   When true, before each run set global-port-print-handler to use
pretty-print from racket/pretty, which is suitable for s-expressions.

   Note: A configure-runtime submodule might replace this initial value
with its own global port print handler – for example to implement
printing a non-s-expression syntax.


File: racket-mode.info,  Node: racket-repl-command-file,  Next: racket-repl-echo-sent-expressions,  Prev: racket-pretty-print,  Up: REPL variables

7.3.11 racket-repl-command-file
-------------------------------

Name of the file used by *note racket-repl::.


File: racket-mode.info,  Node: racket-repl-echo-sent-expressions,  Prev: racket-repl-command-file,  Up: REPL variables

7.3.12 racket-repl-echo-sent-expressions
----------------------------------------

Should commands that send an expresion to the REPL echo it there?

   The echoed expression and “ => ” are displayed using the face *note
racket-repl-message:: to distinguish them from result values.

   Affects *note racket-send-last-sexp::, *note racket-send-region::,
and *note racket-send-definition::.


File: racket-mode.info,  Node: Other variables,  Next: Experimental debugger variables,  Prev: REPL variables,  Up: Variables

7.4 Other variables
===================

* Menu:

* racket-doc-index-directory::
* racket-doc-index-predicate-function::
* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::
* racket-before-run-hook::
* racket-after-run-hook::
* racket-sexp-comment-fade::


File: racket-mode.info,  Node: racket-doc-index-directory,  Next: racket-doc-index-predicate-function,  Up: Other variables

7.4.1 racket-doc-index-directory
--------------------------------

Directory for *note racket-describe-search:: doc index files.


File: racket-mode.info,  Node: racket-doc-index-predicate-function,  Next: racket-indent-curly-as-sequence,  Prev: racket-doc-index-directory,  Up: Other variables

7.4.2 racket-doc-index-predicate-function
-----------------------------------------

A function used by *note racket-describe-search:: to filter results.

   The default value, the ‘always’ function, filters nothing.

   The function is given four string arguments – TERM, WHAT, FROM-LIBS,
and FAMILIES – and should return whether to include the item in the list
of completion candidates.  An example that limits candidates to the
“Rhombus” family:

   (lambda (_term _what _from-libs families) (string-equal families
“Rhombus”)


File: racket-mode.info,  Node: racket-indent-curly-as-sequence,  Next: racket-indent-sequence-depth,  Prev: racket-doc-index-predicate-function,  Up: Other variables

7.4.3 racket-indent-curly-as-sequence
-------------------------------------

Indent ‘{}’ with items aligned with the head item?

   This is indirectly disabled if *note racket-indent-sequence-depth::
is 0.  This is safe to set as a file-local variable.


File: racket-mode.info,  Node: racket-indent-sequence-depth,  Next: racket-pretty-lambda,  Prev: racket-indent-curly-as-sequence,  Up: Other variables

7.4.4 racket-indent-sequence-depth
----------------------------------

To what depth should *note racket-indent-line:: search.

   This affects the indentation of forms like ’() ‘() #() – and {} if
*note racket-indent-curly-as-sequence:: is t — but not #’() #‘() ,()
,@().  A zero value disables, giving the normal indent behavior of
DrRacket or Emacs ‘lisp-mode’ derived modes like ‘scheme-mode’.  Setting
this to a high value can make indentation noticeably slower.  This is
safe to set as a file-local variable.


File: racket-mode.info,  Node: racket-pretty-lambda,  Next: racket-smart-open-bracket-enable,  Prev: racket-indent-sequence-depth,  Up: Other variables

7.4.5 racket-pretty-lambda
--------------------------

Display lambda keywords using λ.  This is DEPRECATED.

   Instead use ‘prettify-symbols-mode’ in newer verisons of Emacs, or,
use *note racket-insert-lambda:: to insert actual λ characters.


File: racket-mode.info,  Node: racket-smart-open-bracket-enable,  Next: racket-logger-config,  Prev: racket-pretty-lambda,  Up: Other variables

7.4.6 racket-smart-open-bracket-enable
--------------------------------------

This variable is obsolete and has no effect.

   Instead of using this variable, you may bind the ‘[’ key to the
‘racket-smart-open-bracket’ command in the ‘racket-mode-map’ and/or
‘racket-repl-mode-map’ keymaps.


File: racket-mode.info,  Node: racket-logger-config,  Next: racket-before-run-hook,  Prev: racket-smart-open-bracket-enable,  Up: Other variables

7.4.7 racket-logger-config
--------------------------

Configuration of *note racket-logger-mode:: topics and levels.

   The topic “*” respresents the default level used for topics not
assigned a level.  Otherwise, the topic symbols are the same as used by
Racket’s ‘define-logger’.

   The levels are those used by Racket’s logging system: “debug”,
“info”, “warning”, “error”, “fatal”.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

   The default value sets some known “noisy” topics to be one level
quieter.  That way you can set the “*” topic to a level like “debug” and
not get overhwelmed by these noisy topics.


File: racket-mode.info,  Node: racket-before-run-hook,  Next: racket-after-run-hook,  Prev: racket-logger-config,  Up: Other variables

7.4.8 racket-before-run-hook
----------------------------

Normal hook done before various Racket Mode run commands.

   Here “before” means that the *note racket-repl-mode:: buffer might
not exist yet.

   When hook functions are called, ‘current-buffer’ is that of the edit
buffer when the run command was issued.  If a hook function instead
needs the *note racket-repl-mode:: buffer, it should get that from the
variable ‘racket-repl-buffer-name’.


File: racket-mode.info,  Node: racket-after-run-hook,  Next: racket-sexp-comment-fade,  Prev: racket-before-run-hook,  Up: Other variables

7.4.9 racket-after-run-hook
---------------------------

Normal hook done after various Racket Mode run commands.

   Here “after” means that the run has completed and the REPL is waiting
at another prompt.

   When hook functions are called, ‘current-buffer’ is that of the
buffer when the run command was issued.  If a hook function instead
needs the *note racket-repl-mode:: buffer, it should get that from the
variable ‘racket-repl-buffer-name’.


File: racket-mode.info,  Node: racket-sexp-comment-fade,  Prev: racket-after-run-hook,  Up: Other variables

7.4.10 racket-sexp-comment-fade
-------------------------------

How much to fade faces used in s-expression comment bodies.

   A number from 0.0 to 1.0, where 0.0 is 0% fade and 1.0 is 100% fade
(invisible).

   This feature works by creating faces that are alternatives for faces
used in s-expression comments.  The alernative faces use a faded
foreground color.  The colors are recalculated automatically after you
change the value of this customization variable and after any
‘load-theme’.  However in other circumstances you might need to use
‘racket-refresh-sexp-comment-faces’.


File: racket-mode.info,  Node: Experimental debugger variables,  Next: Showing information,  Prev: Other variables,  Up: Variables

7.5 Experimental debugger variables
===================================

* Menu:

* racket-debuggable-files::


File: racket-mode.info,  Node: racket-debuggable-files,  Up: Experimental debugger variables

7.5.1 racket-debuggable-files
-----------------------------

Used specify what files to instrument for debugging.

   The value must be either:

   • A list of file name strings.

   • A function that, given the name of the file being run, returns a
     list of file name strings.

   Each file name in the list is made absolute using ‘expand-file-name’
with respect to the file being run and given to
‘racket-file-name-front-to-back’.


File: racket-mode.info,  Node: Showing information,  Next: Running racket and raco commands in a shell or terminal,  Prev: Experimental debugger variables,  Up: Variables

7.6 Showing information
=======================

* Menu:

* racket-show-functions::


File: racket-mode.info,  Node: racket-show-functions,  Up: Showing information

7.6.1 racket-show-functions
---------------------------

An “abnormal hook” variable to customize ‘racket-show’.

   This is a list of one or more functions.

   Each such function must accept two arguments: STR and POS.

   STR is one of:

   • Non-blank string: Display the string somehow.

   • Blank string: Hide any previously displayed string.

   • nil: Hide any persistent UI that might have been created.  For
     instance *note racket-show-header-line:: hides the header line.

   POS may be nil when STR is nil or a blank string.

   Otherwise POS is the buffer position – typically the end of a span –
that the non-blank STR describes.

   A function that shows STR near POS should position it not to hide the
span, i.e.  below and/or right of POS.  Examples: *note
racket-show-pseudo-tooltip:: and *note racket-show-pos-tip::.

   A function that shows STR in a fixed location may of course ignore
POS.  Examples: *note racket-show-echo-area:: and *note
racket-show-header-line::


File: racket-mode.info,  Node: Running racket and raco commands in a shell or terminal,  Next: Racket input method,  Prev: Showing information,  Up: Variables

7.7 Running racket and raco commands in a shell or terminal
===========================================================

* Menu:

* racket-shell-or-terminal-function::


File: racket-mode.info,  Node: racket-shell-or-terminal-function,  Up: Running racket and raco commands in a shell or terminal

7.7.1 racket-shell-or-terminal-function
---------------------------------------

How *note racket-racket:: and *note racket-raco-test:: run commands.

   The function should accept a command string, not including a newline,
get or create a suitable buffer, send the command, and send a newline or
enter.

   Predefined choices include *note racket-shell::, *note racket-term::,
*note racket-ansi-term::, and *note racket-vterm::.


File: racket-mode.info,  Node: Racket input method,  Prev: Running racket and raco commands in a shell or terminal,  Up: Variables

7.8 Racket input method
=======================

* Menu:

* racket-input-prefix::
* racket-input-translations::


File: racket-mode.info,  Node: racket-input-prefix,  Next: racket-input-translations,  Up: Racket input method

7.8.1 racket-input-prefix
-------------------------

A prefix used by the “Racket” input method.

   This string is prepended to the key sequence strings in *note
racket-input-translations::, when setting up the input method.

   Using some non-nil, non-blank prefix avoids conflicts between key
sequences and portions of normal words.  For example “oint” would insert
“∮” while you’re typing “point” – but not “\oint”.

   If you change this setting manually with ‘setq’ (instead of using the
customization buffer or ‘setopt’) you need to call ‘racket-input-setup’
in order for the change to take effect.


File: racket-mode.info,  Node: racket-input-translations,  Prev: racket-input-prefix,  Up: Racket input method

7.8.2 racket-input-translations
-------------------------------

A list of translations.

   Each element is (KEY-SEQUENCE-STRING TRANSLATION-STRING).

   Used by the “Racket” input method activated by *note
racket-input-mode::, as well as by the *note racket-insert-symbol::
command.

   If you change this setting manually with ‘setq’ (instead of using the
customization buffer or ‘setopt’) you need to call ‘racket-input-setup’
in order for the change to take effect.


File: racket-mode.info,  Node: Configuration functions,  Next: Faces,  Prev: Variables,  Up: Top

8 Configuration functions
*************************

* Menu:

* Showing information: Showing information (1).
* Associating edit buffers with REPL buffers::
* Browsing file URLs with anchors::
* Configuring back ends::
* Running racket and raco commands in a shell or terminal: Running racket and raco commands in a shell or terminal (1).


File: racket-mode.info,  Node: Showing information (1),  Next: Associating edit buffers with REPL buffers,  Up: Configuration functions

8.1 Showing information
=======================

* Menu:

* racket-show-pseudo-tooltip::
* racket-show-echo-area::
* racket-show-header-line::
* racket-show-pos-tip::


File: racket-mode.info,  Node: racket-show-pseudo-tooltip,  Next: racket-show-echo-area,  Up: Showing information (1)

8.1.1 racket-show-pseudo-tooltip
--------------------------------

‘(racket-show-pseudo-tooltip str &optional pos)’

   Show using an overlay that resembles a tooltip.

   This is nicer than *note racket-show-pos-tip:: because it:

   • Doesn’t flicker while navigating.
   • Doesn’t disappear after a timeout.
   • Performs well when ‘x-gtk-use-system-tooltips’ is nil.

   On the other hand, this does not look as nice when displaying text
that spans multiple lines or is too wide to fit the window.  In that
case, we simply left-justify everything and do not draw any border.


File: racket-mode.info,  Node: racket-show-echo-area,  Next: racket-show-header-line,  Prev: racket-show-pseudo-tooltip,  Up: Showing information (1)

8.1.2 racket-show-echo-area
---------------------------

‘(racket-show-echo-area str &optional _pos)’

   Show things in the echo area.

   A value for the variable *note racket-show-functions::.

   This does _not_ add STR to the “*Messages*” log buffer.


File: racket-mode.info,  Node: racket-show-header-line,  Next: racket-show-pos-tip,  Prev: racket-show-echo-area,  Up: Showing information (1)

8.1.3 racket-show-header-line
-----------------------------

‘(racket-show-header-line str &optional _pos)’

   Show things using a buffer header line.

   A value for the variable *note racket-show-functions::.

   When there is nothing to show, keep a blank header-line.  That way,
the buffer below doesn’t “jump up and down” by a line as messages appear
and disappear.  Only when V is nil do we remove the header line.


File: racket-mode.info,  Node: racket-show-pos-tip,  Prev: racket-show-header-line,  Up: Showing information (1)

8.1.4 racket-show-pos-tip
-------------------------

‘(racket-show-pos-tip str &optional pos)’

   Show things using ‘pos-tip-show’ if available.

   A value for the variable *note racket-show-functions::.


File: racket-mode.info,  Node: Associating edit buffers with REPL buffers,  Next: Browsing file URLs with anchors,  Prev: Showing information (1),  Up: Configuration functions

8.2 Associating edit buffers with REPL buffers
==============================================

* Menu:

* racket-repl-buffer-name-shared::
* racket-repl-buffer-name-unique::
* racket-repl-buffer-name-project::
* racket-project-root::


File: racket-mode.info,  Node: racket-repl-buffer-name-shared,  Next: racket-repl-buffer-name-unique,  Up: Associating edit buffers with REPL buffers

8.2.1 racket-repl-buffer-name-shared
------------------------------------

‘(racket-repl-buffer-name-shared)’

   Share one *note racket-repl-mode:: buffer per back end.

   A value for the variable *note racket-repl-buffer-name-function::.


File: racket-mode.info,  Node: racket-repl-buffer-name-unique,  Next: racket-repl-buffer-name-project,  Prev: racket-repl-buffer-name-shared,  Up: Associating edit buffers with REPL buffers

8.2.2 racket-repl-buffer-name-unique
------------------------------------

‘(racket-repl-buffer-name-unique)’

   Each *note racket-mode:: edit buffer gets its own *note
racket-repl-mode:: buffer.

   A value for the variable *note racket-repl-buffer-name-function::.


File: racket-mode.info,  Node: racket-repl-buffer-name-project,  Next: racket-project-root,  Prev: racket-repl-buffer-name-unique,  Up: Associating edit buffers with REPL buffers

8.2.3 racket-repl-buffer-name-project
-------------------------------------

‘(racket-repl-buffer-name-project)’

   Share one *note racket-repl-mode:: buffer per back end and per
project.

   A value for the variable *note racket-repl-buffer-name-function::.

   The “project” is determined by *note racket-project-root::.


File: racket-mode.info,  Node: racket-project-root,  Prev: racket-repl-buffer-name-project,  Up: Associating edit buffers with REPL buffers

8.2.4 racket-project-root
-------------------------

‘(racket-project-root file)’

   Given an absolute pathname for FILE, return its project root
directory.

   The “project” is determined by trying, in order:

   • ‘projectile-project-root’, if that exists
   • ‘project-current’
   • ‘file-name-directory’


File: racket-mode.info,  Node: Browsing file URLs with anchors,  Next: Configuring back ends,  Prev: Associating edit buffers with REPL buffers,  Up: Configuration functions

8.3 Browsing file URLs with anchors
===================================

* Menu:

* racket-browse-url-using-temporary-file::


File: racket-mode.info,  Node: racket-browse-url-using-temporary-file,  Up: Browsing file URLs with anchors

8.3.1 racket-browse-url-using-temporary-file
--------------------------------------------

‘(racket-browse-url-using-temporary-file url &rest _args)’

   Browse a URL via a temporary HTML file using a meta redirect.

   A suitable value for the variable *note racket-browse-url-function::.

   Racket documentation URLs depend on anchors – the portion of the URL
after the # character – to jump to a location within a page.
Unfortunately on some operating systems and/or versions of Emacs, the
default handling for browsing file URLs ignores anchors.  This function
attempts to avoid the problem by using a temporary HTML file with a meta
redirect as a “trampoline”.

   Although the intent is to provide a default that “just works”, you do
not need to use this.  You can customize the variable *note
racket-browse-url-function:: instead to be ‘browse-url’, or
‘browse-url-browser-function’ in case have have customized that, or
indeed whatever you want.


File: racket-mode.info,  Node: Configuring back ends,  Next: Running racket and raco commands in a shell or terminal (1),  Prev: Browsing file URLs with anchors,  Up: Configuration functions

8.4 Configuring back ends
=========================

* Menu:

* racket-add-back-end::


File: racket-mode.info,  Node: racket-add-back-end,  Up: Configuring back ends

8.4.1 racket-add-back-end
-------------------------

‘(racket-add-back-end directory &rest plist)’

   Add a description of a Racket Mode back end.

   Racket Mode supports one or more back ends, which are Racket
processes supporting REPLs as well as various other Racket Mode
features.

   DIRECTORY is a string describing a ‘file-name-absolute-p’ directory
on some local or remote server.

   When a back end’s DIRECTORY is the longest matching prefix of a
buffer’s ‘default-directory’, that back end is used for the buffer.

   DIRECTORY can be a local directory like “/” or “/path/to/project”, or
a ‘file-remote-p’ directory like “/user@host:” or
“/user@host:/path/to/project”.

   Note that you need not include a method – such as the “ssh” in
“/ssh:user@host:” – and if you do it is stripped: A back end process is
always started using SSH.  Even if multiple buffers for the same
user+host+port use different methods, they will share the same back end.

   Practically speaking, DIRECTORY is a path you could give to
‘find-file’ to successfully find some local or remote file, but omitting
any method.  (Some remote file shorthand forms get expanded to at least
“/method:host:”.  When in doubt check ‘buffer-file-name’ and follow its
example.)

   In addition to being used as a pattern to pick a back end for a
buffer, DIRECTORY determines:

   • Whether the back end is local or remote.

   • When remote, any explicit user and port used to make SSH
     connections (as opposed to relying on values from ~/.ssh/config).

   • Other properties get reasonable defaults based on whether the back
     end is local or remote, as described below.

   After DIRECTORY, the remainining arguments are optional; they are
alternating :keywords and values describing some other properties of a
back end:

   • :racket-program

     When not nil this is used instead of the value of the customization
     variable *note racket-program::.

   • :remote-source-dir

     Where on a remote host to copy the back end’s *.rkt files when they
     do not exist or do not match the digest of the local files.  This
     must be ‘file-name-absolute-p’ on the remote.  Only supply the
     localname there (not a full ‘file-remote-p’).  The default value is
     “/tmp/racket-mode-back-end”.

   • :windows

     Whether the back end uses Windows style path names.  Used to
     translate betwen slashes and backslashes between the Emacs front
     end (which uses slashes even on Windows) and the Racket back end
     (which expects native backslashes on Windows).

   • :restart-watch-directories

     A list of ‘directory-name-p’ strings.  Each directory, and
     recursively its subdirectories, will be watched for file system
     changes.  After any changes are detected, the next *note
     racket-run:: (or *note racket-run-module-at-point:: etc.)  command
     will ask you if it should restart the back end for you.  This may
     be helpful when you are changing source files used by the back end.

   The default property values are appropriate for whether DIRECTORY is
local or remote:

   • When DIRECTORY is remote, :windows defaults to nil.

   • Otherwise, :windows defaults to a value based on ‘system-type’.

   Although the default values usually “just work” for local and remote
back ends, you might want a special configuration.  Here are a few
examples.

         ;; 1. A back end configuration for "/" is
         ;; created automatically and works fine as a default
         ;; for buffers visiting local files, so we don't need
         ;; to add one here.

         ;; 2. However assume we want buffers under /var/tmp/8.0
         ;; instead to use Racket 8.0.
         (racket-add-back-end "/var/tmp/8.0"
                              :racket-program "~/racket/8.0/bin/racket")

         ;; 3. A back end configuration will be created
         ;; automatically for buffers visiting file names like
         ;; "/ssh:user@linode", so we don't need to add one here.
         ;;
         ;; If ~/.ssh/config defines a Host alias named "linode",
         ;; with HostName and User settings, a file name as simple as
         ;; "/linode:" would work fine with tramp -- and the
         ;; automatically created back end configuration would work
         ;; fine, too.

         ;; 4. For example's sake, assume for buffers visiting
         ;; /ssh:headless:~/gui-project/ we want :racket-program instead
         ;; to be '("xvfb-run" "racket").
         (racket-add-back-end "/ssh:headless:~/gui-project/"
                              :racket-program '("xvfb-run" "racket"))

   If you use various versions of Racket by setting PATH values via
direnv, .envrc files and ‘envrc-global-mode’, then you need a distinct
back end for each such project subdirectory.  One approach is to use
*note racket-add-back-end:: for each project in your Emacs init file.
Another way to is to have a .dir-locals.el file alongside each .envrc
file:

         ((nil . ((eval . (racket-add-back-end default-directory)))))


File: racket-mode.info,  Node: Running racket and raco commands in a shell or terminal (1),  Prev: Configuring back ends,  Up: Configuration functions

8.5 Running racket and raco commands in a shell or terminal
===========================================================

* Menu:

* racket-shell::
* racket-term::
* racket-ansi-term::
* racket-vterm::


File: racket-mode.info,  Node: racket-shell,  Next: racket-term,  Up: Running racket and raco commands in a shell or terminal (1)

8.5.1 racket-shell
------------------

‘(racket-shell cmd)’

   Run CMD using ‘shell’.

   A value for the variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: racket-term,  Next: racket-ansi-term,  Prev: racket-shell,  Up: Running racket and raco commands in a shell or terminal (1)

8.5.2 racket-term
-----------------

‘(racket-term cmd)’

   Run CMD using ‘term’.

   A value for the variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: racket-ansi-term,  Next: racket-vterm,  Prev: racket-term,  Up: Running racket and raco commands in a shell or terminal (1)

8.5.3 racket-ansi-term
----------------------

‘(racket-ansi-term cmd)’

   Run CMD using ‘ansi-term’.

   A value for the variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: racket-vterm,  Prev: racket-ansi-term,  Up: Running racket and raco commands in a shell or terminal (1)

8.5.4 racket-vterm
------------------

‘(racket-vterm cmd)’

   Run CMD using ‘vterm’, if that package is installed.

   A value for the variable *note racket-shell-or-terminal-function::.


File: racket-mode.info,  Node: Faces,  Prev: Configuration functions,  Up: Top

9 Faces
*******

* Menu:

* All::


File: racket-mode.info,  Node: All,  Up: Faces

9.1 All
=======

* Menu:

* racket-keyword-argument-face::
* racket-reader-quoted-symbol-face::
* racket-reader-syntax-quoted-symbol-face::
* racket-here-string-face::
* racket-xp-def-face::
* racket-xp-use-face::
* racket-xp-unused-face::
* racket-xp-tail-target-face::
* racket-xp-tail-position-face::
* racket-xp-binding-lang-face::
* racket-xp-binding-lang-use-face::
* racket-xp-binding-import-face::
* racket-xp-binding-import-use-face::
* racket-xp-binding-local-face::
* racket-xp-binding-local-use-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::
* racket-doc-link-face::
* racket-ext-link-face::
* racket-doc-output-face::
* racket-doc-litchar-face::
* racket-repl-message::
* racket-repl-prompt::
* racket-repl-value::
* racket-repl-error-message::
* racket-repl-error-location::
* racket-repl-stdout::
* racket-repl-stderr::
* racket-hash-lang-text::


File: racket-mode.info,  Node: racket-keyword-argument-face,  Next: racket-reader-quoted-symbol-face,  Up: All

9.1.1 racket-keyword-argument-face
----------------------------------

Face for ‘#:keyword’ arguments.


File: racket-mode.info,  Node: racket-reader-quoted-symbol-face,  Next: racket-reader-syntax-quoted-symbol-face,  Prev: racket-keyword-argument-face,  Up: All

9.1.2 racket-reader-quoted-symbol-face
--------------------------------------

Face for symbols quoted using ’ or ‘.

   This face is given only to symbols directly quoted using the reader
shorthands ’ or ‘.  All other directly quoted values, including symbols
quoted using “quote” or “quasiquote”, get the face
‘font-lock-constant-face’.


File: racket-mode.info,  Node: racket-reader-syntax-quoted-symbol-face,  Next: racket-here-string-face,  Prev: racket-reader-quoted-symbol-face,  Up: All

9.1.3 racket-reader-syntax-quoted-symbol-face
---------------------------------------------

Face for symbols quoted using #’ or #‘.

   This face is given only to symbols directly quoted using the reader
shorthands #’ or #‘.  All other directly quoted values, including
symbols quoted using “syntax” or “quasisyntax”, get the face
‘font-lock-constant-face’.


File: racket-mode.info,  Node: racket-here-string-face,  Next: racket-xp-def-face,  Prev: racket-reader-syntax-quoted-symbol-face,  Up: All

9.1.4 racket-here-string-face
-----------------------------

Face for here strings.


File: racket-mode.info,  Node: racket-xp-def-face,  Next: racket-xp-use-face,  Prev: racket-here-string-face,  Up: All

9.1.5 racket-xp-def-face
------------------------

Face *note racket-xp-mode:: uses when point is on a definition.


File: racket-mode.info,  Node: racket-xp-use-face,  Next: racket-xp-unused-face,  Prev: racket-xp-def-face,  Up: All

9.1.6 racket-xp-use-face
------------------------

Face *note racket-xp-mode:: uses when point is on a use.


File: racket-mode.info,  Node: racket-xp-unused-face,  Next: racket-xp-tail-target-face,  Prev: racket-xp-use-face,  Up: All

9.1.7 racket-xp-unused-face
---------------------------

Face *note racket-xp-mode:: uses to highlight unused requires or
definitions.


File: racket-mode.info,  Node: racket-xp-tail-target-face,  Next: racket-xp-tail-position-face,  Prev: racket-xp-unused-face,  Up: All

9.1.8 racket-xp-tail-target-face
--------------------------------

Face *note racket-xp-mode:: uses to highlight targets of a tail
position.


File: racket-mode.info,  Node: racket-xp-tail-position-face,  Next: racket-xp-binding-lang-face,  Prev: racket-xp-tail-target-face,  Up: All

9.1.9 racket-xp-tail-position-face
----------------------------------

Face *note racket-xp-mode:: uses to highlight expressions in a tail
position.


File: racket-mode.info,  Node: racket-xp-binding-lang-face,  Next: racket-xp-binding-lang-use-face,  Prev: racket-xp-tail-position-face,  Up: All

9.1.10 racket-xp-binding-lang-face
----------------------------------

Face *note racket-xp-mode:: gives to the module language name.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-xp-binding-lang-use-face,  Next: racket-xp-binding-import-face,  Prev: racket-xp-binding-lang-face,  Up: All

9.1.11 racket-xp-binding-lang-use-face
--------------------------------------

Face *note racket-xp-mode:: gives uses of bindings imported from the
module language.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-xp-binding-import-face,  Next: racket-xp-binding-import-use-face,  Prev: racket-xp-binding-lang-use-face,  Up: All

9.1.12 racket-xp-binding-import-face
------------------------------------

Face *note racket-xp-mode:: gives to imported module names.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-xp-binding-import-use-face,  Next: racket-xp-binding-local-face,  Prev: racket-xp-binding-import-face,  Up: All

9.1.13 racket-xp-binding-import-use-face
----------------------------------------

Face *note racket-xp-mode:: gives uses of imported bindings.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-xp-binding-local-face,  Next: racket-xp-binding-local-use-face,  Prev: racket-xp-binding-import-use-face,  Up: All

9.1.14 racket-xp-binding-local-face
-----------------------------------

Face *note racket-xp-mode:: gives to local definitions.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-xp-binding-local-use-face,  Next: racket-logger-config-face,  Prev: racket-xp-binding-local-face,  Up: All

9.1.15 racket-xp-binding-local-use-face
---------------------------------------

Face *note racket-xp-mode:: gives to uses of local definitions.

   See the variable ‘nil’.


File: racket-mode.info,  Node: racket-logger-config-face,  Next: racket-logger-topic-face,  Prev: racket-xp-binding-local-use-face,  Up: All

9.1.16 racket-logger-config-face
--------------------------------

Face for *note racket-logger-mode:: configuration.


File: racket-mode.info,  Node: racket-logger-topic-face,  Next: racket-logger-fatal-face,  Prev: racket-logger-config-face,  Up: All

9.1.17 racket-logger-topic-face
-------------------------------

Face for *note racket-logger-mode:: topics.


File: racket-mode.info,  Node: racket-logger-fatal-face,  Next: racket-logger-error-face,  Prev: racket-logger-topic-face,  Up: All

9.1.18 racket-logger-fatal-face
-------------------------------

Face for *note racket-logger-mode:: fatal level.


File: racket-mode.info,  Node: racket-logger-error-face,  Next: racket-logger-warning-face,  Prev: racket-logger-fatal-face,  Up: All

9.1.19 racket-logger-error-face
-------------------------------

Face for *note racket-logger-mode:: error level.


File: racket-mode.info,  Node: racket-logger-warning-face,  Next: racket-logger-info-face,  Prev: racket-logger-error-face,  Up: All

9.1.20 racket-logger-warning-face
---------------------------------

Face for *note racket-logger-mode:: warning level.


File: racket-mode.info,  Node: racket-logger-info-face,  Next: racket-logger-debug-face,  Prev: racket-logger-warning-face,  Up: All

9.1.21 racket-logger-info-face
------------------------------

Face for *note racket-logger-mode:: info level.


File: racket-mode.info,  Node: racket-logger-debug-face,  Next: racket-doc-link-face,  Prev: racket-logger-info-face,  Up: All

9.1.22 racket-logger-debug-face
-------------------------------

Face for *note racket-logger-mode:: debug level.


File: racket-mode.info,  Node: racket-doc-link-face,  Next: racket-ext-link-face,  Prev: racket-logger-debug-face,  Up: All

9.1.23 racket-doc-link-face
---------------------------

Face *note racket-describe-mode:: uses for links within documentation.
Note: When some special face is already specified by the documentation,
then to avoid visual clutter this face is NOT also added.


File: racket-mode.info,  Node: racket-ext-link-face,  Next: racket-doc-output-face,  Prev: racket-doc-link-face,  Up: All

9.1.24 racket-ext-link-face
---------------------------

Face *note racket-describe-mode:: uses for external links.  See the
variable *note racket-browse-url-function::.


File: racket-mode.info,  Node: racket-doc-output-face,  Next: racket-doc-litchar-face,  Prev: racket-ext-link-face,  Up: All

9.1.25 racket-doc-output-face
-----------------------------

Face *note racket-describe-mode:: uses for Scribble @example or
@interactions output.


File: racket-mode.info,  Node: racket-doc-litchar-face,  Next: racket-repl-message,  Prev: racket-doc-output-face,  Up: All

9.1.26 racket-doc-litchar-face
------------------------------

Face *note racket-describe-mode:: uses for Scribble @litchar.


File: racket-mode.info,  Node: racket-repl-message,  Next: racket-repl-prompt,  Prev: racket-doc-litchar-face,  Up: All

9.1.27 racket-repl-message
--------------------------

Face *note racket-repl-mode:: uses for messages from the back end.


File: racket-mode.info,  Node: racket-repl-prompt,  Next: racket-repl-value,  Prev: racket-repl-message,  Up: All

9.1.28 racket-repl-prompt
-------------------------

Face *note racket-repl-mode:: uses for prompts.


File: racket-mode.info,  Node: racket-repl-value,  Next: racket-repl-error-message,  Prev: racket-repl-prompt,  Up: All

9.1.29 racket-repl-value
------------------------

Face *note racket-repl-mode:: uses for ‘print’-ed values.


File: racket-mode.info,  Node: racket-repl-error-message,  Next: racket-repl-error-location,  Prev: racket-repl-value,  Up: All

9.1.30 racket-repl-error-message
--------------------------------

Face *note racket-repl-mode:: uses for error messages.


File: racket-mode.info,  Node: racket-repl-error-location,  Next: racket-repl-stdout,  Prev: racket-repl-error-message,  Up: All

9.1.31 racket-repl-error-location
---------------------------------

Face *note racket-repl-mode:: uses for error locations.


File: racket-mode.info,  Node: racket-repl-stdout,  Next: racket-repl-stderr,  Prev: racket-repl-error-location,  Up: All

9.1.32 racket-repl-stdout
-------------------------

Face *note racket-repl-mode:: uses for output to current-output-port.


File: racket-mode.info,  Node: racket-repl-stderr,  Next: racket-hash-lang-text,  Prev: racket-repl-stdout,  Up: All

9.1.33 racket-repl-stderr
-------------------------

Face *note racket-repl-mode:: uses for output to current-error-port.


File: racket-mode.info,  Node: racket-hash-lang-text,  Prev: racket-repl-stderr,  Up: All

9.1.34 racket-hash-lang-text
----------------------------

Face *note racket-hash-lang-mode:: uses for text tokens.



Tag Table:
Node: Top311
Node: Introduction7448
Node: Install Update and Uninstall8679
Node: Use Emacs 281 or newer with NonGNU ELPA9390
Node: Configure Emacs to use MELPA9817
Node: Install10698
Node: Minimal Racket11325
Node: Uninstall12639
Node: Update12948
Node: Upgrading all packages13132
Node: Updating just Racket Mode14092
Node: Configure14658
Node: Which major mode to use15979
Node: Key bindings18843
Node: Font-lock (syntax highlighting)19506
Node: Completion at point20961
Node: Completion in minibuffer22923
Node: Xref (definitions and references)23575
Node: Indent26532
Node: paredit27299
Node: smartparens29302
Node: Appearance of parentheses29857
Node: Edit buffers and REPL buffers30251
Node: eldoc31795
Node: Start faster33238
Node: Inserting Unicode math symbols33475
Node: Ligatures33891
Node: Architecture34588
Ref: Architecture-Footnote-138025
Node: Reference38410
Node: Commands38905
Node: Edit39155
Node: racket-mode39719
Node: racket-insert-lambda44399
Node: racket-insert-symbol44669
Node: racket-fold-all-tests45238
Node: racket-unfold-all-tests45475
Node: racket-tidy-requires45718
Node: racket-trim-requires46423
Node: racket-base-requires47247
Node: racket-add-require-for-identifier48129
Node: racket-indent-line48968
Node: racket-smart-open-bracket-mode52922
Node: racket-insert-closing55372
Node: racket-cycle-paren-shapes55865
Node: racket-backward-up-list56116
Node: racket-input-mode56659
Node: racket-align58553
Node: racket-unalign60593
Node: racket-complete-at-point60926
Node: Hash Langs61348
Node: racket-hash-lang-mode61645
Node: racket-hash-lang-backward66387
Node: racket-hash-lang-forward66670
Node: racket-hash-lang-up66948
Node: racket-hash-lang-down67216
Node: racket-hash-lang-C-M-q-dwim67484
Node: Explore68003
Node: racket-xp-mode68562
Node: racket-xp-describe77407
Node: racket-xp-documentation79011
Node: racket-xp-next-definition80165
Node: racket-xp-previous-definition80428
Node: racket-xp-next-use80698
Node: racket-xp-previous-use80957
Node: racket-xp-next-error81219
Node: racket-xp-previous-error81489
Node: racket-xp-tail-up81770
Node: racket-xp-tail-down82234
Node: racket-xp-tail-next-sibling82515
Node: racket-xp-tail-previous-sibling82817
Node: racket-documentation-search83139
Node: racket-describe-mode84165
Node: racket-describe-search88069
Node: Run88339
Node: racket-repl-mode88786
Node: racket-run93626
Node: racket-run-and-switch-to-repl95679
Node: racket-run-module-at-point96135
Node: racket-repl96642
Node: racket-repl-describe97579
Node: racket-repl-documentation99067
Node: racket-racket100185
Node: racket-profile100524
Node: racket-profile-mode101242
Node: racket-logger102430
Node: racket-logger-mode102651
Node: racket-repl-clear103789
Node: racket-repl-clear-leaving-last-prompt104377
Node: Test104692
Node: racket-test104837
Node: racket-raco-test105671
Node: Eval106020
Node: racket-send-region106212
Node: racket-send-definition106508
Node: racket-send-last-sexp106835
Node: Collections107301
Node: racket-open-require-path107468
Node: Macro expand108079
Node: racket-stepper-mode108352
Node: racket-expand-file109529
Node: racket-expand-region110232
Node: racket-expand-definition110645
Node: racket-expand-last-sexp111081
Node: Packages111480
Node: racket-package-refresh111714
Node: list-racket-packages112054
Node: racket-package-mode112347
Node: describe-racket-package113401
Node: Debug114776
Node: racket-debug-mode115369
Node: racket-debug-step118324
Node: racket-debug-step-over118582
Node: racket-debug-step-out118848
Node: racket-debug-forward-breakable119108
Node: racket-debug-backward-breakable119512
Node: racket-debug-run-to-here119925
Node: racket-debug-set-break-expression120320
Node: racket-debug-clear-break-expression122623
Node: racket-debug-toggle-break-expression123003
Node: racket-debug-forward-break-expression123411
Node: racket-debug-backward-break-expression123758
Node: racket-debug-set-local124097
Node: racket-debug-continue124352
Node: racket-debug-go124725
Node: Other125132
Node: racket-mode-start-faster125292
Node: racket-mode-start-slower126637
Node: Variables126932
Node: General variables127299
Node: racket-program127818
Node: racket-command-timeout128486
Node: racket-memory-limit128956
Node: racket-error-context129562
Node: racket-user-command-line-arguments130679
Node: racket-browse-url-function131547
Node: racket-xp-after-change-refresh-delay131952
Node: racket-xp-highlight-unused-regexp132369
Node: racket-xp-add-binding-faces132818
Node: racket-xp-eldoc-level133654
Node: racket-documentation-search-location134326
Node: racket-expand-hiding135184
Node: Hash lang variables135436
Node: racket-hash-lang-token-face-alist135694
Node: racket-hash-lang-module-language-hook137173
Node: REPL variables140631
Node: racket-repl-buffer-name-function141168
Node: racket-submodules-to-run142203
Node: racket-repl-history-directory142950
Node: racket-history-filter-regexp143233
Node: racket-images-inline143585
Node: racket-imagemagick-props143833
Node: racket-images-keep-last144441
Node: racket-images-system-viewer144695
Node: racket-images-do-not-use-svg144978
Node: racket-pretty-print145412
Node: racket-repl-command-file145969
Node: racket-repl-echo-sent-expressions146231
Node: Other variables146748
Node: racket-doc-index-directory147237
Node: racket-doc-index-predicate-function147494
Node: racket-indent-curly-as-sequence148207
Node: racket-indent-sequence-depth148634
Node: racket-pretty-lambda149324
Node: racket-smart-open-bracket-enable149731
Node: racket-logger-config150187
Node: racket-before-run-hook151038
Node: racket-after-run-hook151640
Node: racket-sexp-comment-fade152245
Node: Experimental debugger variables152951
Node: racket-debuggable-files153196
Node: Showing information153742
Node: racket-show-functions154001
Node: Running racket and raco commands in a shell or terminal155096
Node: racket-shell-or-terminal-function155427
Node: Racket input method155988
Node: racket-input-prefix156235
Node: racket-input-translations156994
Node: Configuration functions157596
Node: Showing information (1)158036
Node: racket-show-pseudo-tooltip158343
Node: racket-show-echo-area159062
Node: racket-show-header-line159480
Node: racket-show-pos-tip160059
Node: Associating edit buffers with REPL buffers160390
Node: racket-repl-buffer-name-shared160804
Node: racket-repl-buffer-name-unique161203
Node: racket-repl-buffer-name-project161669
Node: racket-project-root162184
Node: Browsing file URLs with anchors162663
Node: racket-browse-url-using-temporary-file162966
Node: Configuring back ends164057
Node: racket-add-back-end164338
Node: Running racket and raco commands in a shell or terminal (1)169548
Node: racket-shell169904
Node: racket-term170205
Node: racket-ansi-term170527
Node: racket-vterm170869
Node: Faces171205
Node: All171322
Node: racket-keyword-argument-face172399
Node: racket-reader-quoted-symbol-face172621
Node: racket-reader-syntax-quoted-symbol-face173143
Node: racket-here-string-face173680
Node: racket-xp-def-face173908
Node: racket-xp-use-face174146
Node: racket-xp-unused-face174375
Node: racket-xp-tail-target-face174639
Node: racket-xp-tail-position-face174919
Node: racket-xp-binding-lang-face175213
Node: racket-xp-binding-lang-use-face175529
Node: racket-xp-binding-import-face175877
Node: racket-xp-binding-import-use-face176201
Node: racket-xp-binding-local-face176531
Node: racket-xp-binding-local-use-face176849
Node: racket-logger-config-face177175
Node: racket-logger-topic-face177438
Node: racket-logger-fatal-face177684
Node: racket-logger-error-face177934
Node: racket-logger-warning-face178186
Node: racket-logger-info-face178443
Node: racket-logger-debug-face178691
Node: racket-doc-link-face178936
Node: racket-ext-link-face179322
Node: racket-doc-output-face179618
Node: racket-doc-litchar-face179894
Node: racket-repl-message180147
Node: racket-repl-prompt180393
Node: racket-repl-value180612
Node: racket-repl-error-message180849
Node: racket-repl-error-location181103
Node: racket-repl-stdout181361
Node: racket-repl-stderr181610
Node: racket-hash-lang-text181853

End Tag Table


Local Variables:
coding: utf-8
End:
