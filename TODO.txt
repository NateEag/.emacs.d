Until I get my task tracker semi-workable, I'm going to keep the list of things I wish my emacs rig did as a simple TODO file.

Note that a lot of these aren't emacs-specific - they're just things I wish my editor would do. elisp is Turing-complete, though, even if it's not a great language overall...

-I really want a block-comment-mode. Basically, when I'm writing block comments, I shouldn't need to worry about when to line-wrap and where to break. It's like plain text, more or less. It needs not to interfere when I'm customizing indentation, but basically, I should be able to say "start a block comment", and it should flow/wrap my text for me, with whatever syntax is used for block comments by the current major-mode. (In python-mode, something similar should be done for docstrings.)

-It might be interesting to experiment with semantic-coding commands. This idea was inspired by thinking about yasnippet, and how basically, it's used to cut down on boilerplate. Boilerplate is semi-language-specific, but it's really got more to do with individual programmers' styles - there are common idioms, but everyone tends to have their own. So, might it be interesting to build some interface to a collection of snippets that's basically "Do this idiom for the current language"? Block-comment's one emacs already has, but there are lots: debug output, while loop/for loop, if/else, if/elif/else, new class, new function, etc... This whole idea isn't entirely unrelated to refactoring, actually.

-Fix auto-complete.el in Aquamacs. I'm not sure why everything chunks, nor why line heights change when it activates/deactivates, but it'd be really nice to get it working. A simple test case is probably the first step...

-Get ropemode/auto-complete.el completing .-expressions. I know ropemode can do it, so it seems like it should be a pretty simple change to get this working. A bit of aimless reading on the Emacs wiki makes me think ac-omni-completion-sources might relate to this somehow. I'm not quite sure, but I keep seeing comments about that and .- and -> expressions in C, so it seems that it might relate somehow.

-Get tab behaving properly. That means calling yasnippet/code-completion as appropriate, indentation when appropriate, retaining minibuffer autocompletion, and Shift-Tab cycling backwards through autocompletions (sometimes you go too far, eh?).

-Get yasnippet working. For now, it's okay if I don't use tab as the keybinding - that's some sweet-looking software, and I really want to start integrating it into my workflow. Yeah, I'll go crazy when I'm stuck on systems that don't have it, but it looks really neat. (Hmmm, interesting thought - I'd probably start to forget the details of syntax for snippets I relied on extensively. How much help from your editor is too much?)

-This is long-term, since my task tracker doesn't exist yet, but I'd like to hack up a basic minor-mode for it, if it ever gets far enough for that to be useful. Subtle hints when a name/block has annotations (toggleable, of course), easy keystroke to view the associated annotation/task, easy way to create annotations/attach existing annotations to some code... I should probably do this in elisp, not because it's the right thing from an engineering perspective, but because it would force me to learn a lot about the language. It'd be annoying to have to do all the work again in elisp, though, and there is Pymacs...

-When I'm yanking something into an indented block, python-mode ought to assume that I want it indented to that block's depth and adjust the leading whitespace for each line accordingly. This applies to indentation in general; it might  work in most modes, for all I know. With Python, there's the perennial problem of no delimiters; it's not necessarily right to go to the highest possible indentation on a newline. For yanking, though, I'll bet it's the right call most of the time. If it's not, you're just an indent command away from having the right depth.
